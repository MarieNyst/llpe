#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass sigplanconf
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
conferenceinfo{PLDI 2013}{16--21 June 2013, Seattle, USA} 
\backslash
copyrightyear{2012} 
\end_layout

\end_inset


\end_layout

\begin_layout Title
LLPE: A Practial Specialiser for LLVM Programs
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
authorinfo{Christopher Smowton and Steven Hand} {University of Cambridge}
 {
\backslash
{first.last
\backslash
}@cl.cam.ac.uk}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The software we use on a day-to-day is often much more general than it needs
 to be for the task for which it is employed.
 Specialised software can consume less memory, energy and execution time
 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

, but specialisation of large programs for a specific task is seldom seen
 in practice.
 This is because hand-specialising programs is time-consuming and error-prone,
 with the development and testing time likely to outweigh the resources
 saved running the specialised software (TODO: find a good citation for
 'reusing existing, general software is usually a good idea').
 By automating the specialisation process, specialisation can be turned
 from a task of weeks to one of hours, and therefore made practically applicable
 to everyday real-world programs.
\end_layout

\begin_layout Standard
Partial evaluation is a program transformation which can perform automated
 specialisation.
 In this paper, we present the design of a partial evaluator (PE) for real-world
-scale LLVM 
\begin_inset CommandInset citation
LatexCommand cite
key "lattner2004llvm"

\end_inset

 programs, which specialises whole programs with respect to command-line
 parameters, environment variables and/or filesystem images.
 We aim for high accuracy and minimum user input into the specialisation
 process.
\end_layout

\begin_layout Standard
PEs must trade off between the cost of specialisation and how closely they
 can approximate theoretically optimal specialisation, called their accuracy.
 We target use cases where a specialised program is expected to be used
 many times before it is re-specialised, and so performance of the specialised
 program is much more important than that of the specialiser; therefore
 we adopt an 
\emph on
online
\emph default
 PE strategy (see below) in order to achieve very high accuracy.
\end_layout

\begin_layout Standard
Because we aim to automate the PE process entirely, we aggressively explore
 all possible paths of execution in the target program, restricted to ensure
 
\emph on
soundness
\emph default
 (the emitted program must be observationally equivalent to the input program,
 modulo specialised arguments) and 
\emph on
termination
\emph default
 of the specialiser.
 However because proving termination is difficult, we also degrade gracefully
 to support simple, easy-to-use annotations that provide hints when our
 PE would otherwise underspecialise the input program.
\end_layout

\begin_layout Standard
By targeting LLVM intermediate representation (IR), our PE can exploit many
 useful properties of the LLVM ecosystem.
 We can easily specialise whole programs consisting of more than one translation
 unit, including library code, without requiring user description of externals,
 since LLVM tools make it easy to produce final linked IR images which retain
 sufficient high-level semantic information for program transformations
 like PE.
 Due to the widespread availability of compilers targeting LLVM, we can
 also target programs written in many source languages, including C, Objective-C
, C++ and Haskell amongst others, as well as multi-lingual projects (e.g.
 a C++ program linking a pure C library).
\end_layout

\begin_layout Standard
We have implemented a prototype realising a large portion of our design.
 In section Blah we describe our implementation, along with the challenges
 we anticipate in fully realising our design.
 We evaluated our prototype on 3 mid-sized programs (10,000s of source lines
 of code, including libraries), producing code size reductions of up to
 X% and runtime improvements of up to Y%.
\end_layout

\begin_layout Subsection
Contributions
\end_layout

\begin_layout Standard
The contributions of this paper relative to prior work are:
\end_layout

\begin_layout Itemize
A design for a PE targeting LLVM IR, including a novel online PE algorithm
 that works by a form of abstract interpretation and a novel 
\begin_inset Quotes eld
\end_inset

storeless
\begin_inset Quotes erd
\end_inset

 approach to handling memory side-effects.
\end_layout

\begin_layout Itemize
A user-customisable algorithm for estimating the cost of PE decisions, allowing
 the user to trade output program code size against performance.
\end_layout

\begin_layout Itemize
An evaluation of the cost and benefits of specialisation applied to whole,
 real-world programs.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
It is common for very general software to be used where a more specialised
 program would have done the job.
 Apache, with its cornucopia of modules and features, is often used to serve
 static content; grep is used when its search expression is so simple that
 it boils down to 
\family typewriter
strstr
\family default
; fully-featured databases with support for ACID transactions and clustering
 are used in applications that in fact only call for a single-user hash
 table.
 This usually happens out of expediency: the tool exists, is familiar to
 the user, definitely does the required job (despite doing many dozens of
 other things as well), and there is little motivation to invent a better
 solution when resources (CPU cycles, memory) are plentiful.
\end_layout

\begin_layout Standard
It is also common to need to employ such general-purpose, inefficient prototypes
 in a setting where resource consumption is important.
 This might be because the prototype will be run in a cloud computing environmen
t which is billed per CPU cycle or byte of memory consumed, or because the
 ultimate target is an embedded environment with physical resource restrictions,
 or because a network service became unexpectedly popular to the point that
 it taxes its host hardware.
 In such cases we'd like to use the same all-purpose tools we're familiar
 with, but we need to compromise to meet our resource budget.
 We could customise the software by hand, but the development and debugging
 costs of such modifications may be excessive.
 We could sacrifice functionality and use a system designed explicitly for
 restricted environments (such as trading in GNU Coreutils for 
\family typewriter
busybox
\family default
), but such an alternative might not be readily available, and the replacement
 is likely to have subtly different behaviour and bugs to the original,
 or may offer a restricted feature subset that is not convenient to our
 needs.
\end_layout

\begin_layout Standard
Using partial evaluation we can have our cake and eat it too: the existing,
 large program can be specialised with respect to invariants that we know
 about its operating context to produce a smaller, faster program that behaves
 identically to the original so long as the invariants are maintained and
 the specialiser is correct.
\end_layout

\begin_layout Subsection
Partial Evaluation
\end_layout

\begin_layout Standard
Partial evaluation (PE), also known as program specialisation or staged
 compilation, describes the evaluation of part of a program, usually assuming
 some specialisation conditions, and emission of a residual program which
 is observationally equivalent to the original so long as those specialisation
 conditions are obeyed.
\end_layout

\begin_layout Standard
As a trivial example, one could specialise the 
\family typewriter
printf
\family default
 function to assume that its first argument will be 
\family typewriter
"%d"
\family default
.
 Under this assumption, printf reduces to a function that prints a single
 integer as a decimal.
 The resulting code will be smaller, as printf's other output routines can
 be discarded, and faster to execute, because instructions that examine
 the format string can be evaluated ahead of time.
 The specialised function might be small enough to consider inlining, which
 will eliminate the cost of a call/return sequence entirely.
 The emitted specialisation of printf is equivalent to the original so long
 as the specialisation condition (that the first parameter is 
\family typewriter
"%d"
\family default
) is true.
\end_layout

\begin_layout Standard
PE of entire programs extends this idea by specialising with respect to
 the arguments supplied to the program's entry point (i.e.
 its command-line arguments or environment), as well as implicit parameters
 examined using system calls, such as the contents of the filesystem.
 Whilst specialisation conditions for internal functions can be proven by
 the specialiser (for example, it will never emit code using its specialised
 
\family typewriter
printf
\family default
 unless it is sure the parameters are appropriate), specialisation with
 respect to external state requires that we either depend on the user to
 obey those conditions (with undefined behaviour if they don't), or that
 the specialiser emits code to check those conditions (called guards).
 For example, if the 
\family typewriter
printf
\family default
 example above were to take its format string from a command-line argument,
 we would either note that calling with a different format string will lead
 to undefined behaviour or emit a guard which checks that the format string
 is as expected and exits otherwise.
 Which of these is appropriate depends on context: in an embedded context
 we can likely guarantee appropriate usage because we have full control
 over device firmware, whilst for personal use it is probably more useful
 to provide informative errors at the expense of code size and runtime.
\end_layout

\begin_layout Standard
PE can take place ahead of time (sometimes called static PE), in which specialis
ation conditions are specified in advance and a specialised program is produced
 but the specialiser plays no further role at runtime, or can take place
 at runtime (called a dynamic partial evaluator), in which the specialiser
 is present in the executable and generates code at hand-specified points,
 or in response to dynamic profiling of the executing code, akin to a just-in-ti
me compiler.
\end_layout

\begin_layout Subsubsection
Online vs.
 Offline Partial Evaluation
\end_layout

\begin_layout Standard
All PEs, when given an input program to specialise, must at some point determine
 which computations in that program should be evaluated at specialisation
 time (termed 
\emph on
static
\emph default
 statements or expressions) and which must be suspended until the specialised
 program is run (termed 
\emph on
dynamic
\emph default
).
 An online partial evaluator takes this decision when given both an input
 program and concrete values for some of its parameters; by contrast an
 offline partial evaluator decides based on the input program and a 
\emph on
division
\emph default
 of its arguments (a division specifies which arguments will be supplied
 at specialisation time, and which will be supplied at runtime), but 
\emph on
without
\emph default
 knowledge of the arguments' concrete values 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

.
\end_layout

\begin_layout Standard
Offline partial evaluators thus operate in two phases: the first determines
 which statements and expressions in the source program can be evaluated
 at specialisation time, called 
\emph on
Binding-Time Analysis
\emph default
 (BTA), and then the second uses the BTA result to emit a specialised program
 given concrete argument values.
\end_layout

\begin_layout Standard
Offline PE often faster than online PE because its BTA is less precise and
 thus less expensive to compute than determining whether every instruction
 can be executed "on the fly," as in online PE.
 For example, it is usual for offline BTA to classify instructions in a
 loop as static or dynamic once, rather than classifying them once per iteration
 as in online PE.
 The results of the precomputed BTA can also be saved and reused for different
 values of the specialisation-time arguments.
\end_layout

\begin_layout Standard
By contrast, online PE is usually more precise because it can use full knowledge
 of the concrete values of specialisation-time parameters to determine which
 computations can be executed at specialisation time, whilst an offline
 PE uses the approximation given by its BTA, which must make worst-case
 assumptions about parameters' concrete values.
\end_layout

\begin_layout Standard
The offline BTA described so far is a monovariant BTA, which is usual for
 offline PEs targeting imperative languages 
\begin_inset CommandInset citation
LatexCommand cite
key "christensen2000btasize"

\end_inset

.
 A monovariant BTA assigns a single binding time to each identifier in the
 input program per program point.
 By contrast, a polyvariant BTA 
\begin_inset CommandInset citation
LatexCommand cite
key "christensen2000btasize"

\end_inset

 may assign more than one binding time per program point, to be used when
 specialised code in different contexts.
 For example, a monovariant BTA analysing a loop containing a variable which
 is sometimes static and sometimes dynamic at the head of the loop would
 produce a specialiser that conservatively assumes it is always dynamic,
 and therefore would always residualise computations of its value, whilst
 a polyvariant BTA might generate two different binding times and thus specialis
ation plans for the loop body: one to use when the variable static, and
 another to use when it is dynamic.
 This would yield a superior specialisation as more instructions can be
 executed at specialisation time.
 Perhaps surprisingly, a maximally polyvariant BTA is provably capable of
 specialising as accurately as an online PE 
\begin_inset CommandInset citation
LatexCommand cite
key "christensen2004offvsonline"

\end_inset

.
\end_layout

\begin_layout Standard
For a full analysis of the costs and benefits of online vs.
 offline PE, see Ruf's thesis 
\begin_inset CommandInset citation
LatexCommand cite
key "ruf1993onlinepe"

\end_inset

.
\end_layout

\begin_layout Standard
We chose to implement an online PE, because we aim to produce highly specialised
 programs which we expect to re-specialise infrequently, meaning we value
 the efficiency of the specialised program more than that of the specialiser
 itself.
 Whilst an offline PE could be realised that would achieve both goals, we
 expect it to be much more complex to design and implement in practice.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
We present the design of an ahead-of-time online PE for LLVM bitcode.
 It combines well-known analyses using a novel specialisation strategy to
 produce a specialiser capable of processing real-world programs, surpassing
 previous work in the scale of its input programs and its coverage of the
 source language.
\end_layout

\begin_layout Standard
Our high-level design goals are as follows:
\end_layout

\begin_layout Itemize

\emph on
Soundness
\emph default
.
 We specialise programs using properties which we can establish for certain
 given the specialisation conditions, and make no further assumptions about
 the program's input or the behaviour of the target machine beyond those
 embodied in the LLVM specification and the target architecture if one is
 provided by the frontend compiler.
 Naturally the threat of bugs in the specialiser remains, but we seek the
 minimise the risk by using well-exercised kernels from core LLVM transformation
 passes as much as possible.
\end_layout

\begin_layout Itemize

\emph on
Accuracy
\emph default
.
 Only the most basic cases of PE provide all the information relevant to
 running a program (e.g.
 providing a complete filesystem image, environment and command-line to
 a program that does not interact with the network, system timer, or other
 sources of non-determinism).
 Inevitably therefore there will be aspects of the program whose behaviour
 remains unknown.
 If entirely unknown these dynamic regions of the program can act as optimisatio
n barriers because they must be assumed to affect any memory location.
 We avoid this situation by supporting multiple levels of understanding
 of the effects of instructions and functions: they can be understood to
 affect particular memory addresses, or entire objects or allocations.
\end_layout

\begin_layout Itemize

\emph on
Scalability
\emph default
.
 In order to effectively specialise large programs, it is necessary to prove
 facts across a large codebase: for example, to show that a global variable
 accessed late in execution still has its initialiser value requires us
 to establish that no intervening instruction has written to that variable.
 We achieve scalability using multiple levels of analysis, characterising
 functions' and loops' behaviour first in a context-insensitive manner,
 then again considering their parameters, and then finally, if necessary,
 considering their dynamic execution context.
 This enables us to abbreviate program analysis by dealing in entire functions
 and loops wherever possible, only considering their fine details where
 necessary.
\end_layout

\begin_layout Itemize

\emph on
Usability
\emph default
.
 Inevitably, automatic analysis will sometimes fail to fully exploit the
 available information and produce suboptimal output.
 For these cases we support easy to understand and use annotations, allowing
 the user to provide extra guidance without threatening correctness.
\end_layout

\begin_layout Itemize

\emph on
Practicality
\emph default
.
 We target LLVM bitcode in order to support programs written in many low-level
 programming languages, including C and C++, whilst providing a source language
 whose semantics are well specified and which is small enough that broad
 coverage is practical.
\end_layout

\begin_layout Standard
We will describe the detailed design of our specialiser starting with a
 simple core design which is then augmented to take advantage of more specialisa
tion opportunities and to improve efficiency.
 We use a series of illustrative example programs which are expressed in
 LLVM-like pseudocode.
\end_layout

\begin_layout Subsection
Concrete Online PE
\end_layout

\begin_layout Standard
Our PE, as most online PEs, is structured similar to an interpreter.
 Starting at the program entry point, it symbolically executes each LLVM
 instruction, calculating its result if its arguments are known to the PE
 or leaving the instruction unresolved (and therefore to be residualised
 in the specialised program) otherwise.
 For the time being we will only consider instructions to have a known,
 concrete result (of any LLVM data type, including pointers) or to be entirely
 unknown, but we will lift this restriction later.
\end_layout

\begin_layout Standard
Like an ordinary interpreter, when our PE encounters a call instruction
 it recurses to evaluate the called function; similarly when loops are controlle
d by a static termination condition it will iterate through the loop at
 specialisation time, analysing the loop body individually for each iteration.
 To phrase these properties another way, our analysis of the source program
 is 
\emph on
context-sensitive
\emph default
 and 
\emph on
flow-sensitive
\emph default
.
\end_layout

\begin_layout Standard
We diverge from ordinary interpretation when we encounter a conditional
 branch which cannot be decided at specialisation time (i.e.
 a 
\emph on
dynamic branch
\emph default
).
 In this case both successor basic blocks need to be residualised using
 our usual interpretation method.
\end_layout

\begin_layout Standard
LLVM IR is for the most part in Single Static Assignment (SSA) form, which
 means that there is usually no need to determine the 'current' value of
 a variable, as data flow is explicitly represented in the IR.
 As such, our interpreter does not need to maintain a store for these values.
 On the other hand, LLVM has 
\family typewriter
load
\family default
 and 
\family typewriter
store
\family default
 instructions, which deal with stack, heap and global memory, none of which
 is in SSA form.
 We resolve 
\family typewriter
load
\family default
 instructions by walking backwards through the program's control-flow graph
 (CFG) looking for store instructions accessing the same memory.
\end_layout

\begin_layout Standard
Whilst most PEs perform alias analysis before analysing the source program
 (for example, Tempo 
\begin_inset CommandInset citation
LatexCommand cite
key "consel1996tempobasic"

\end_inset

 and C-Mix 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

 both adopt this approach), we determine pointer aliases on the fly, using
 addresses calculated earlier in interpretation.
 This improves our PE's accuracy over PEs conducting the two analyses seperately
, because PE can kill the instructions that cause potential aliasing, which
 in turn can lead to better PE results.
\end_layout

\begin_layout Standard
At control flow merges, most PEs must determine whether the two possible
 predecessors could have resulted in contradictory stores and merge the
 two (see for example Tempo or JSpec 
\begin_inset CommandInset citation
LatexCommand cite
key "schultz2003jspec"

\end_inset

); however, for SSA identifiers a merge is explicitly indicated in LLVM
 IR by a 
\family typewriter
phi
\family default
 instruction.
 We interpret these by checking whether all live blocks would feed it the
 same concrete value; if not we leave it with an unknown value.
 Contradictory values stored to memory are naturally handled by our approach
 to resolving 
\family typewriter
load
\family default
 instructions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename integrator-diagrams/fig1a.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example program that incorporates a loop (BB1), a call within a loop
 (call f within BB1), and memory operations
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename integrator-diagrams/fig1b.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The same program as figure 1, annotated with the constant and pointer results
 computed for each dynamic instruction
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To give an example of our PE described so far, Figure 1 shows a program
 involving 2 functions, 
\family typewriter
main
\family default
 and 
\family typewriter
f
\family default
, and Figure 2 shows the values our PE computes for each iteration of the
 loop with header 
\family typewriter
BB1
\family default
 and each invocation of the call to 
\family typewriter
f
\family default
.
 We are able to calculate values for 
\family typewriter
%2 = load %1
\family default
 within 
\family typewriter
f
\family default
 by establishing in each case a unique store that defines that load (in
 the first case this is 
\family typewriter
store 7 -> %2
\family default
 in the entry block of 
\family typewriter
main()
\family default
, in the second it is 
\family typewriter
store 5 -> %1
\family default
 within the first call to 
\family typewriter
f
\family default
).
\end_layout

\begin_layout Standard
When emitting specialised code we inline functions and peel loops to write
 the straightened control flow graph we have established will be executed,
 replacing instructions with constants and pointers as we go.
 As all instructions are either evaluated to constants or dead (without
 users) when constant instructions are disregarded, the output program is
 simply 
\family typewriter
ret 12
\family default
.
\end_layout

\begin_layout Subsubsection
Ensuring PE Termination
\end_layout

\begin_layout Standard
If our approach so far were applied naively, there are many input programs
 that would cause infinite PE.
 For example, a potentially infinite recursive call to a function, or a
 loop controlled by a dynamic branch, could result in our specialising an
 infinite number of procedure calls or basic blocks respectively, even if
 the infinite recursion or loop would not be entered at runtime.
\end_layout

\begin_layout Standard
To ensure PE termination, we only permit potentially infinite exploration
 such as this on paths which are certain to be executed at runtime.
 To be precise, we investigate loops only if their header block post-dominates
 the program exit, and stop iterating if we find that an iteration has live
 exit edges.
 Calls are not explored if they would enter a recursion (that is, if another
 call to the same function is on the stack) unless the basic block containing
 the call instruction post-dominates the caller's exit block.
 Thus the PE can only enter an infinite loop if the program under specialisation
 would do so as well, which is usually regarded as acceptable behaviour
 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

.
 Nontheless if a certain path 
\emph on
is
\emph default
 certain to execute we explore its control flow as aggressively as possible.
\end_layout

\begin_layout Subsection
System Call Support
\end_layout

\begin_layout Standard
We support a subset of system calls commonly used to import information
 that constitutes a specialisation condition, such as the contents of the
 filesystem, and understand file descriptors as first-class objects.
 We establish the sequence of system calls operating on a file descriptor
 by trying to find a unique predecessor call for each such system call,
 thus constructing a chain of operations leading from an 
\family typewriter
open
\family default
 call to one or more 
\family typewriter
close
\family default
 calls.
 We track a file descriptor's current file position along with the descriptor,
 and if we are able to prove the file and position going into a 
\family typewriter
read
\family default
 call we can solve 
\family typewriter
load
\family default
 instructions that draw from the buffer passed to that call.
 We can completely eliminate VFS system calls if we can identify and resolve
 every use of an open call.
 
\end_layout

\begin_layout Standard
We also hard-code knowledge of the side-effects of other system calls that
 don't provide useful information: for example, we document that 
\family typewriter
clock_gettime
\family default
 writes through its arguments, writing dynamic data, and sets 
\family typewriter
errno
\family default
 but has no other effects.
 This is to avoid system calls presenting a barrier to most memory forwarding
 operations.
\end_layout

\begin_layout Standard
The file system contents might change after specialisation but before, or
 during, runtime.
 At present, like with command-line parameters, we require that the user
 ensures this does not happen by specialising only with respect to files
 they are confident will not change, for example because they are part of
 a read-only filesystem image.
 However, other options exist: we could augment the program to check that
 files referenced have not been changed, and/or lock them during execution.
 We discuss the possibilities for augmenting LLPE with guards under Future
 Work, below.
\end_layout

\begin_layout Subsection
Partially Dynamic Values
\end_layout

\begin_layout Standard
A significant limitation of the design as described so far is that it assigns
 each instruction either a concrete result (a constant or known pointer)
 or else assumes the instruction could have any result at all, even if its
 range remains limited: for example, according to LLVM semantics a pointer
 derived from another by pointer arithmetic must continue to point to the
 same allocated object (global variable, stack allocation or 
\family typewriter
malloc
\family default
 call).
 Knowing that a pointer addresses a particular object is very useful, even
 if its exact address is unknown, because a 
\family typewriter
store
\family default
 to a pointer that could address any object is a significant barrier to
 further specialisation, preventing us from establishing the result of any
 
\family typewriter
load
\family default
 instruction whose value may be defined before that 
\family typewriter
store
\family default
.
 To address this limitation, we extend our notion of instruction results
 to include two new kinds of information: 
\emph on
value sets
\emph default
, and 
\emph on
fuzzy pointers
\emph default
.
 
\end_layout

\begin_layout Standard
We allow our interpreter's instruction evaluation routine to return a 
\emph on
set
\emph default
 of result values.
 These are produced when a 
\family typewriter
phi
\family default
 instruction has several live predecessor blocks, when a select instruction
 (which functions like C's ternary 
\family typewriter
x ? y : z
\family default
 operator) has an unknown first operand, or when a 
\family typewriter
load
\family default
 instruction might be defined by more than one 
\family typewriter
store
\family default
.
 Arithmetic and bitwise operations can be assigned value sets if one or
 more of their operands have been assigned sets: for example, if 
\family typewriter
%1
\family default
 were assigned 
\family typewriter
{1, 2}
\family default
 and 
\family typewriter
%2
\family default
 were assigned 
\family typewriter
{4, 8}
\family default
 then 
\family typewriter
add %1, %2
\family default
 would be assigned 
\family typewriter
{5, 6, 9, 10}.
\end_layout

\begin_layout Standard
In effect, tracking value sets in this way is similar to specialisation
 by continuations used by some offline PEs: these handle control flow merges
 by specialising the merge block for both possible predecessors (for example,
 C-Mix's treatment of the mergepoint after an 
\family typewriter
if
\family default
 / 
\family typewriter
else
\family default
 block 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename integrator-diagrams/fig2a.svg
	height 30theight%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example program illustrating value sets: because 
\family typewriter
BB2
\family default
's predecessor may be either the entry block or 
\family typewriter
BB1
\family default
, 
\family typewriter
phi
\family default
 node 
\family typewriter
%4
\family default
 is assigned the union of the values of its arguments, but 
\family typewriter
%5
\family default
 is nontheless assigned a single value.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figure 3 we give an example showing how tracking value sets per instruction
 can improve specialisation opportunities.
 The phi instruction 
\family typewriter
%4
\family default
 can have two possible values because the condition for the branch at 
\family typewriter
%2
\family default
 is dynamically controlled, leaving all shown blocks live.
 At 
\family typewriter
%5
\family default
 however the 
\family typewriter
and
\family default
 operation masks the dynamic element of its operand out, leaving a single
 concrete value which can be used to expose further opportunities for specialisa
tion.
 This limits the scope of the uncertainty implied by dynamic parameter 
\family typewriter
%dynamic
\family default
.
 In order to avoid an explosion in the time and space needed for specialisation,
 once a value set grows larger than a user-controllable threshold it is
 considered wholly dynamic (i.e.
 we assume it may take any value, as for an instruction with no result calculate
d).
 This threshold can be adjusted to trade memory consumption for quality
 of specialisation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename integrator-diagrams/fig2b.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example program illustrating fuzzy pointers: the notation 
\begin_inset Quotes eld
\end_inset


\family typewriter
pointer %1@main + ?
\family default

\begin_inset Quotes erd
\end_inset

 indicates the pointer has a known base object (
\family typewriter
%1
\family default
, a stack allocated object) but an unknown offset.
 This is enough to establish that 
\family typewriter
store 6 -> %4
\family default
 does not modify the distinct object 
\family typewriter
%2
\family default
 and therefore the 
\family typewriter
load %6
\family default
's value can be established for certain.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A special case of a value set is a 
\emph on
fuzzy pointer
\emph default
: this is a pointer whose base object is known, but whose offset within
 that object is not.
 In figure 4 we see a known pointer is indexed by a dynamic offset and then
 stored to.
 Without a fuzzy pointer association for the resulting pointer 
\family typewriter
%4
\family default
 we would need to assume that the store operation alters all memory, but
 knowing its base object we can assume that pointers with other known base
 objects do not alias it, thus constraining the 
\family typewriter
store
\family default
's side-effects.
 Thus whilst the load 
\family typewriter
%5
\family default
 cannot be completed because its value may or may not be affected by the
 store to 
\family typewriter
%4
\family default
, the 
\family typewriter
load %6
\family default
 can as it is known to reference a different object.
\end_layout

\begin_layout Standard
Value sets and fuzzy pointers can be combined to produce a value which notionall
y points to one of several possible objects with an unknown offset.
 This value may alias another pointer if any of its set of bases may alias.
\end_layout

\begin_layout Standard
Previous PEs also needed to constrain the side-effects of store operations
 for the same reason, typically achieved by an alias analysis pass before
 PE as described in section 3.1.
 In this context a set of fuzzy pointers would be called a pointer's 
\emph on
points-to set
\emph default
.
 The advantage of our approach is that we take the results of interpretation
 so far into account when calculating points-to sets and so can find smaller
 sets, constraining side-effects more and blocking further specialisation
 less.
\end_layout

\begin_layout Standard
Instructions whose calculated values remain sets or fuzzy pointers at the
 end of specialisation are residualised in the output program like those
 with unknown results.
 However if their users were evaluated to concrete constants, as in this
 case, they will be identified as dead instructions and removed in a final
 cleanup pass.
\end_layout

\begin_layout Subsection
Dynamic Loops and Calls
\end_layout

\begin_layout Standard
Another limitation of our design described so far is that because we try
 to establish values for instructions in loops on a per-iteration basis,
 and we only explore the next iteration when we are certain the loop will
 iterate, our progress will be severely limited when the input program contains
 a loop whose iteration count cannot be statically established because it
 depends on user input, or a nondeterministic system call.
 We now expand our analysis of loops to try to establish both per-iteration
 values and invariant values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename integrator-diagrams/fig3a.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example program illustrating the value of loop invariant analysis.
 The per-iteration analysis on the right is forestalled by uncertainty about
 the latch branch, whilst the invariant analysis on the left limits the
 loop's side effects such that 
\family typewriter
%7
\family default
 can be established.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 5 we show an example program in which the dynamic argument 
\family typewriter
%dynamic
\family default
 controls a loop which iterates through a buffer, writing some number of
 null bytes.
 Our simple strategy of following the program's dynamic execution flow like
 an interpreter is inadequate here, because we don't know how many times
 the loop will iterate.
 Instead, we consider the loop at two different scales: we try to investigate
 each iteration, as well as to establish invariants regarding the loop body.
 The per-iteration (flow-sensitive) investigation, represented by the block
 labelled 
\begin_inset Quotes eld
\end_inset

BB1 (iteration 1)
\begin_inset Quotes erd
\end_inset

 stalls quickly, establishing the exact object and offset modified by 
\family typewriter
store 0 -> %2
\family default
, but unable to proceed further because it is uncertain whether the loop
 will iterate or not and stops to avoid the risk of PE non-termination (in
 fact we would have to explore a potentially infinite number of iterations
 to establish the loop's results and effects).
 The invariant analysis, on the other hand, establishes that instructions
 
\family typewriter
%2
\family default
 and 
\family typewriter
%4
\family default
 always refer to a pointer within the buffer 
\family typewriter
%1
\family default
.
 This does not improve the emitted program, because no concrete values are
 established, however critically it establishes that 
\family typewriter
store 0 -> %2
\family default
 does not modify 
\family typewriter
@global
\family default
, since it is distinct from the stack allocation 
\family typewriter
%1
\family default
, permitting us to resolve the 
\family typewriter
load
\family default
 
\family typewriter
%7
\family default
.
\end_layout

\begin_layout Standard
Our loop invariant analysis includes considering 
\family typewriter
call
\family default
 instructions within an invariant context.
 For example, if the program in Figure 5 defined a trivial two argument
 function 
\family typewriter
f(%x, %y) { store %x -> %y }
\family default
 and called 
\family typewriter
f(0, %2)
\family default
 in place of 
\family typewriter
store 0 -> %2
\family default
, we would consider the call to 
\family typewriter
f
\family default
 both in the 
\family typewriter
BB1
\family default
 (invariants) context and the 
\family typewriter
BB1
\family default
 (iteration 1) context.
 We would establish that the call only affects the stack object 
\family typewriter
%1
\family default
 and so achieve the same successful forwarding of 
\family typewriter
%7
\family default
.
\end_layout

\begin_layout Standard
Figure 6 shows a more complex example program that illustrates how our loop
 invariant analysis investigates calls and subloops nested within the loop
 under consideration.
 It features a loop that repeatedly calls 
\family typewriter
bset
\family default
, which is modelled on a highly simplified 
\family typewriter
fwrite
\family default
 function, in that it takes a pointer into a buffer, writes some number
 of bytes then stores a pointer to the next byte to be written.
 Whilst 
\family typewriter
fwrite
\family default
 keeps that pointer within 
\family typewriter
struct FILE
\family default
 rather than taking it directly, 
\family typewriter
bset
\family default
 exhibits the key challenge in analysing an 
\family typewriter
fwrite
\family default
 loop: establishing that 
\emph on
every
\emph default
 call to 
\family typewriter
fwrite
\family default
 can only modify a particular buffer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename integrator-diagrams/fig6.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example program illustrating exploring a function in a loop-invariant
 context.
 We successfully prove that every call to 
\family typewriter
bset
\family default
 within the left-hand loop writes only to the buffer 
\family typewriter
%buf
\family default
, limiting the side-effects of the unbounded loop.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By exploring 
\family typewriter
bset
\family default
 in the context of 
\family typewriter
main
\family default
's loop we establish that 
\family typewriter
bset
\family default
's parameter 
\family typewriter
%pptr
\family default
 is always 
\family typewriter
main
\family default
's stack allocated 
\family typewriter
%pptr
\family default
, and that 
\family typewriter
bset
\family default
's instruction 
\family typewriter
%1 = load %pptr
\family default
 is always defined by either 
\family typewriter
main
\family default
's 
\family typewriter
store %buf -> %pptr
\family default
 or 
\family typewriter
bset
\family default
's own 
\family typewriter
store %7 -> %pptr
\family default
, both of which write pointers into 
\family typewriter
%buf
\family default
.
 Therefore 
\family typewriter
store c -> %2
\family default
 always only affects 
\family typewriter
%buf
\family default
 and so we are able to limit the side-effects of the call to 
\family typewriter
bset
\family default
 and so the whole unbounded loop in 
\family typewriter
main
\family default
.
 Both the loop in main and the loop in bset would in fact be investigated
 on a per-iteration basis as well, like in Figure 5, but they fail in the
 same way because neither loop's termination condition can be statically
 determined and we omit them from the diagram for brevity.
 Note that if main called 
\family typewriter
bset
\family default
 with a fixed 
\family typewriter
%n
\family default
 parameter then the loop within 
\family typewriter
bset
\family default
 would be expanded to all its iterations rather than being analysed to discover
 loop invariants, though the outcome would be the same as 
\family typewriter
main
\family default
's loop's termination condition remains unknown.
\end_layout

\begin_layout Standard
Unlike all scenarios considered so far, reasoning about unbounded loops
 requires our PE to resolve circular dependencies between instructions,
 such as 
\family typewriter
%2
\family default
 and 
\family typewriter
%4
\family default
 in Figure 5.
 We resolve the dependency using a standard fixpoint method, repeatedly
 lowering in-loop instructions' results precision until a consistent solution
 if found.
 Lowering precision here means adding more values to a set-typed result,
 or downgrading an exact pointer to a fuzzy pointer, or replacing any result
 with an entirely unknown value.
 This process always terminates, because value sets have an upper size limit,
 meaning each value can only be downgraded a finite number of times, and
 a finite number of instructions are considered.
\end_layout

\begin_layout Subsection
Context-insensitive Analysis
\end_layout

\begin_layout Standard
Our design as elaborated thus far is effective, but inefficient.
 In part this is because functions called in many different contexts are
 explored once per dynamic invocation.
 This may be useful if we are looking to establish their dynamic results,
 but often we are only interested in their side-effects, for example because
 their parameters are dynamic and so we are solely concerned with preventing
 them from obstructing memory operations that cross the call site.
 To make our program analysis faster, and save the memory that would be
 consumed exploring the function's effects at every callsite, we introduce
 a context-insensitive characterisation of functions' memory side-effects
 that is calculated the first time a function's side-effects present an
 obstacle to specialisation.
\end_layout

\begin_layout Standard
We calculate for each function a set of modified locations, defined in terms
 of the function's pointer-typed arguments, global variables and escaping
 allocation calls (calls which have the LLVM 
\begin_inset Quotes eld
\end_inset

noalias
\begin_inset Quotes erd
\end_inset

 attribute attached to their return value, which binds them to return a
 fresh pointer; such calls include 
\family typewriter
malloc
\family default
 as well as custom allocators obeying a similar contract).
 The function's set of side-effects is calculated by running our usual PE
 algorithm in the restricted context of the function under investigation,
 regarding pointer-typed arguments as first-class objects.
\end_layout

\begin_layout Standard
Sub-calls to other functions are represented as an inclusion along with
 a substitution: for example, if function f has two pointer-typed parameters,
 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
, and modifies 
\family typewriter
x
\family default
 but then calls itself recursively with the parameters reversed, we represent
 it as modifying 
\family typewriter
x
\family default
, plus its own modification set under the substitution 
\family typewriter
[x/y, y/x]
\family default
.
 For this purpose allocation instructions are represented as static callsites.
 Once all functions are so characterised, we have a recurrence relation
 between functions' modification sets.
 We solve by iterating the inclusion and substitution of other functions'
 sets of modified locations.
 This is guaranteed to terminate because there are a finite number of arguments,
 global variables and static allocation sites in the program, and a finite
 number of functions under consideration, and each step can only make modificati
on sets larger or terminate the algorithm.
\end_layout

\begin_layout Standard
The upshot of this pre-pass is that load forwarding across a call to a function
 which has been established to have simple effects can proceed without needing
 to investigate the function at each callsite.
 We investigate the function at each callsite regardless if we have concrete
 values for its arguments, since these may provide specialisation opportunities,
 or reduce its side-effects further.
\end_layout

\begin_layout Subsection
Program Annotations
\end_layout

\begin_layout Standard
For any specialisation algorithm there will be programs which present specialisa
tion opportunities the analysis does not discover.
 Our specialiser in particular might fall short of ideal specialisation
 because it does not analyse a call or loop iteration because of the limits
 on exploration described in section 3.1.1, put in place to ensure PE termination.
 We might also overestimate the memory side-effects of a section of code,
 either because we did not analyse enough of its calls and loops to fully
 characterise its effects, or because its effects were too complex to describe
 and we were compelled to fall back to supposing it writes all of memory.
 To address both these cases, we support simple, expressive program annotations
 which the user can apply to improve specialisation results.
 The available annotations are:
\end_layout

\begin_layout Itemize

\emph on
Assume edge taken
\emph default
: this authorises the specialiser to analyse calls and loops downstream
 of the assumed edge as aggressively as if the edge was certain to be taken.
 It does not render the output incorrect if the branch goes the other way
 at runtime, but could cause PE non-termination.
 This annotation is useful if the specialiser is reluctant to explore loop
 iterations due to an exit edge which remains alive but which the programmer
 knows is unlikely to be taken, e.g.
 an exit edge dealing with memory allocation failure.
\end_layout

\begin_layout Itemize

\emph on
Expected exit edge
\emph default
: of a loop, this nominates a particular edge as the expected way to leave
 a loop, authorising the PE to investigate the next iteration as soon as
 the nominated edge is killed in the current iteration.
 A more aggressive version of the 
\emph on
assume edge taken
\emph default
 annotation, this should be used for loops which may exit on many unusual
 error conditions, but which normally have a known iteration count.
\end_layout

\begin_layout Itemize

\emph on
Always/never explore
\emph default
: override the specialiser's heuristics and always/never explore calls to
 a particular function.
\end_layout

\begin_layout Standard
In discussing our evaluation in section 6 we describe how and why these
 annotations were used in practice.
 We anticipate significantly reducing the need for annotations as our heuristic
 analysis improves, and describe this in section 7.
\end_layout

\begin_layout Subsection
Adaptive program exploration
\end_layout

\begin_layout Standard
Once we have analysed the entire program, we are now faced with a standard
 problem for PEs: was our specialisation worth it? When we have analysed
 calls and loops in the program, should we replace them with specialised
 versions, perhaps inlined or unrolled into their parent context, or leave
 them alone to avoid an explosion in code size?
\end_layout

\begin_layout Standard
We use a simple, user-customisable metric to decide which calls and loops
 should ultimately be residualise.
 The cost of peeling loop iterations or specialising functions to their
 call site is that by generating extra static instructions we will make
 the specialised program larger.
 This will certainly fill more space on disk and take longer to load into
 memory, either at startup or as pages are faulted in.
 It may also take longer to execute due to i-cache effects.
 On the other hand, if we do peel a loop or specialise a function, we will
 save the time spent executing instructions which could be evaluated at
 specialisation time.
 We weight these competing costs by user-supplied coefficients, so that
 the basic benefit score for specialising a loop or call is (a * code size
 increase) + (b * instructions eliminated), with a and b varied to vary
 the importance attached to the two factors.
\end_layout

\begin_layout Standard
An additional cost of leaving a function unspecialised or a loop unpeeled
 is that this prevents us from specialising any nested loops or calls.
 Therefore when deciding which loops and calls to specialise we walk the
 tree of loops and calls from the bottom up, first calculating benefit scores
 for loops and calls without children, then for their parents, taking into
 account that declining to specialise a parent will remove the benefit of
 the child.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
We have implemented a prototype that includes most features of our design.
 We have not yet implemented the context-insensitive analysis step, which
 we approximate by investigating every call-site independently at the cost
 of some analysis time and memory.
\end_layout

\begin_layout Standard
Our prototype is written as an LLVM 2.8 program analysis/transformation pass.
 We use and adapt many existing LLVM analyses and transformations, including
 their implementation of sparse conditional constant propagation (SCCP),
 their basic alias analysis, and their loop peeling and function inlining
 utilities.
 
\end_layout

\begin_layout Subsection
Implementing PE
\end_layout

\begin_layout Standard
We assume that all functions used in the PE input program are defined (i.e.
 the function body is available for analysis), with the exception of system
 calls.
 This is typically achieved by running the specialiser against a fully staticall
y linked program; however our specialiser does not in principle preclude
 using shared objects in the final binary, as library functions could be
 externalised post-analysis and dynamically re-linked at runtime.
 We do not currently implement this functionality, however.
\end_layout

\begin_layout Standard
To specialise a program we start at a nominated entry function (for C programs
 this should be 
\family typewriter
libc_main
\family default
 rather than 
\family typewriter
main
\family default
, to take library initialisation into account), then walk the program's
 interprocedural control flow graph (CFG) evaluating instructions as described
 in our design above.
\end_layout

\begin_layout Standard
In parts of the program that can be topologically ordered (i.e.
 acyclic subgraphs of the CFG) we visit basic blocks in topological order
 to ensure that all instructions are evaluated after their arguments.
\end_layout

\begin_layout Standard
In cyclic parts of the program we track the dependencies between instructions,
 re-analysing each whenever its result may have changed.
 Normal instructions depend on their arguments, 
\family typewriter
phi
\family default
 instructions depend on their arguments and the CFG (i.e.
 they are re-evaluated if the local CFG changes), and 
\family typewriter
load
\family default
 instructions depend on 
\family typewriter
store
\family default
 instructions that may define their result and the CFG.
\end_layout

\begin_layout Standard
We represent the program as a tree of 'integration contexts'.
 Each context corresponds to a dynamic function invocation or loop iteration,
 and assigns result values to instructions in that scope.
 Figure 7 shows part of the tree of integration contexts that would be produced
 investigating the example program shown in figure 1.
 Note that seperate contexts are created for the invocation of 
\family typewriter
f
\family default
 per iteration, rather than sharing one and conflating their results, correspond
ing to our strategy of maximally polyvariant analysis to achieve high accuracy.
 These contexts provide a convenient way to name a specific execution of
 an instruction, which we use to refer to a particular dynamic stack or
 heap allocation, rather than conflating allocations at a particular callsite.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename integrator-diagrams/fig7.svg
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Excerpt from the tree of integration contexts produced analysing the program
 in Figure 1.
 Iterations after 3 are omitted.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To describe loops in the CFG we use LLVM's standard 
\family typewriter
loops
\family default
 analysis, which constructs a tree of loops each of which is characterised
 by a header block which dominates the rest of the loop, and which is unique
 (i.e.
 the block is not also the header of another loop), and a single backedge.
 
\family typewriter
for
\family default
 and 
\family typewriter
while
\family default
 loops have this structure, but more complicated loop structures can be
 built using source language features such as C's 
\family typewriter
goto
\family default
 instruction, or may be emitted by compilers even if the user's code is
 simple: for these cases we preprocess the program using a somewhat augmented
 version of LLVM's standard 
\family typewriter
loopsimplify
\family default
 pass, which automatically simplifies all cyclic CFGs to fit this tree-of-simple
-loops form.
\end_layout

\begin_layout Standard
After LLPE has completely analysed the target program, we determine which
 loops and calls to peel and inline as described in section 3.7, before using
 LLVM's standard loop peeling and procedure inlining utilities to generate
 the specialised program.
 We do not currently emit any code until the program has been completely
 analysed, so that we can postpone the decision about whether early parts
 of the program are worth specialising until we have seen whether the informatio
n we discovered had beneficial results later on.
 This means that we must be able to store the complete graph of integration
 contexts in memory, which limits the scale of program we can currently
 handle; however we do not expect it to be difficult to scale up to larger
 programs by writing intermediate specialisation results to disk.
\end_layout

\begin_layout Subsection
Language Coverage
\end_layout

\begin_layout Standard
Our current implementation achieves very high coverage of the LLVM intermediate
 language.
 We support many language constructs which are typically omitted from PEs
 because they are too difficult to implement (e.g.
 C-Mix omits all treatment of heap memory 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

, and JSpec conflates all objects allocated at a call-site for lack of names
 for individual allocations 
\begin_inset CommandInset citation
LatexCommand cite
key "schultz2003jspec"

\end_inset

).
\end_layout

\begin_layout Standard
Specifically, we are able to specialise programs featuring:
\end_layout

\begin_layout Itemize
Pointer arithmetic, so long as it is restricted to addition, subtraction,
 comparison, and examination of the lower bits of a pointer that are determined
 by its alignment.
 Pointers can be compared arbitrarily with other pointers that have a common
 base object, and compared for equality whether they have a common base
 or not
\end_layout

\begin_layout Itemize
Evaluation of 
\family typewriter
load
\family default
 instructions using 
\family typewriter
malloc
\family default
'd memory, or memory from another user-nominated allocator obeying the same
 contract.
\end_layout

\begin_layout Itemize
Evaluation of load instructions whose results depend on target-specific
 struct layout, array alignment and similar.
 This is possible because LLVM IR explicitly encodes the target-specific
 layout and alignment rules which will be used when lowering to assembly.
\end_layout

\begin_layout Itemize
Evaluation of 
\family typewriter
load
\family default
s that are defined by stores of a different type (e.g.
 2 
\family typewriter
i16
\family default
 stores that define an 
\family typewriter
i32
\family default
 load).
\end_layout

\begin_layout Itemize
Exceptions as implemented by the 
\family typewriter
llvm-g++
\family default
 and 
\family typewriter
clang
\family default
 compilers.
\end_layout

\begin_layout Standard
Our coverage is not 100% however.
 We still lack support for programs that use pointer arithmetic not covered
 above: we do not support arbitrary inspection of the high bits of a pointer,
 as a hash table might use to determine the pointer's hash bucket, or comparison
 of pointers without a common base as might be used to sort an array of
 pointers.
 Our support for data reinterpretation is limited to non-pointer types.
\end_layout

\begin_layout Standard
We also currently do not support inline assembly, although the impact of
 this limitation is minimised because we support 
\family typewriter
memset
\family default
, 
\family typewriter
memcpy
\family default
 and 
\family typewriter
memmove
\family default
 as intrinsics.
\end_layout

\begin_layout Standard
We discuss the impact and potential resolution of these limits in the future
 work section below.
\end_layout

\begin_layout Subsection
Post-processing
\end_layout

\begin_layout Standard
After the main PE phase has completed, LLPE runs a series of cleanup passes
 over the program to be emitted.
 These are conceptually seperate from PE, in that they do not use the detailed
 analysis that drives PE but rather can be run entirely seperately, but
 they are important to fully realising the benefits of PE and are included
 in our evaluation results below.
\end_layout

\begin_layout Standard
Post-PE cleanup passes are used to eliminate dead stores (i.e.
 store instructions which cannot possibly be read), dead allocation sites
 including 
\family typewriter
malloc
\family default
 / 
\family typewriter
realloc
\family default
 / 
\family typewriter
free
\family default
 graphs that no longer have 
\family typewriter
load
\family default
 or 
\family typewriter
store
\family default
 users, dead global variables, and 
\family typewriter
open
\family default
 / 
\family typewriter
close
\family default
 calls that are not otherwise used.
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialised (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction (%)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300456
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
240968
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
68704
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24472
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64.4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
229504
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
214688
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16528
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13568
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
date
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialised (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction (%)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
284024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
255360
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
59520
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38184
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
220536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
214320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14216
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13392
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
printf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialised (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction (%)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256168
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
240640
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35776
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27848
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
218776
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
211090
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13944
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13328
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
md5sum
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We evaluated our prototype specialiser using 3 sample programs from the
 GNU coreutils: 
\family typewriter
date
\family default
, 
\family typewriter
printf
\family default
 and 
\family typewriter
md5sum
\family default
.
 All were statically linked against uclibc.
\end_layout

\begin_layout Standard

\family typewriter
date
\family default
 was specialised with respect to its environment, which sets the LC family
 of locale variables to en_GB.UTF-8 and its command line, which is empty.
 It is also specialised with respect to the contents of /etc/timezone and
 /etc/TZ, which give the local system's preferred timezone.
 This yields a date program which is specialised to display the time (discarding
 the ability to set the time) in a particular timezone and with the program's
 default format.
 We discuss the program's structure and the code eliminated in detail below.
\end_layout

\begin_layout Standard

\family typewriter
printf
\family default
 was specialised with respect to its environment, which sets the LC variables
 as for 
\family typewriter
date
\family default
, and partially with respect to its command line: we specify that its first
 argument is 
\family typewriter

\begin_inset Quotes eld
\end_inset

%d %s
\begin_inset Quotes erd
\end_inset


\family default
 and that the total number of arguments is (appropriately) 3, but leave
 the other two arguments unspecified.
 This produces a printf program which renders exactly one number and then
 one string, allowing us to discard formatting code for other types.
 This models the kind of specialisation we could make if we saw a script
 which contained the text 
\family typewriter
'/usr/bin/printf 
\begin_inset Quotes eld
\end_inset

%d %s
\begin_inset Quotes erd
\end_inset

 $1 $2'
\family default
.
 The code size reduction for this program results mainly from eliminating
 several functions in the printf family: in particular we are able to discard
 large sections of code dedicated to dealing with wide character strings
 as we are able to establish that with this format string those routines
 will never be called.
\end_layout

\begin_layout Standard
Finally, 
\family typewriter
md5sum
\family default
 was specialised with respect to its command-line and the contents of the
 file it digests.
 Perhaps surprisingly this does not lead to much of a reduction in code
 size: this is because the implementation of the md5 algorithm is quite
 small.
 The residual code is mostly part of the 
\family typewriter
stdio
\family default
 library, used to print the now-known result to stdout.
 We are also forced to retain error-reporting code paths that are exercised
 when printing to stdout fails.
\end_layout

\begin_layout Standard
Tables 1, 2 and 3 summarise the code size reductions achieved, giving the
 byte sizes for each program as stored on disk, as well as the ELF file's
 given size for the text, rodata and bss segments, representing the elimination
 of code, constant data and global variables respectively.
 No other segments contributed more than 1% of any object's size.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
To give an example of the kind of optimisation opportunities available through
 specialisation, we describe an example in detail: the date program.
\end_layout

\begin_layout Standard
The program is ostensibly simple: all it must do is print and set the system
 time.
 However, despite the time being necessarily a dynamic parameter, it is
 possible to specialise the date program to a significant degree, improving
 both its running time and its code and date size.
\end_layout

\begin_layout Standard
We specialise the date program with respect to its environment, which defines
 the locale rules for printing numbers, dates and times using the LC_ family
 of variables, the command-line, which we define to be empty (yielding a
 program that just prints the date), and the files /etc/TZ and /etc/timezone,
 which specify the local timezone.
\end_layout

\begin_layout Standard
The program's structure is more complicated than it would intuitively seem,
 because of support for several different operations (setting the time,
 reading a file timestamp, reading a file that itself lists files), and
 because of support for many different locales with different conventions
 for time representation.
\end_layout

\begin_layout Standard
Its implementation is also inefficient due to expediency on the part of
 the developers: they wished to support specification of the date format
 string using a language which is similar to, but slightly extended from,
 that accepted by strftime.
 In order to avoid rewriting strftime in its entirety, they filter its output,
 repeatedly calling it with short (single-replacement) format strings.
 However, each call to strftime results in two calls to tzset, both of which
 read anew the local machine's timezone information, stored in /etc/TZ or
 /etc/timezone.
\end_layout

\begin_layout Standard
The result is that the apparently simple task of printing the date string
 is achieved by two large parsers (each of strftime and the wrapper function
 fills roughly 8K in the binary image).
 Along with fscanf and strptime, which are only used in the time-setting
 path, inlining these functions reduces the program's code size by around
 20%, and statically evaluating the repeated calls to tzset, including their
 filesystem operations, reduces running time by 10% with a hot page cache
 (i.e., with the /etc/timezone file already in memory).
\end_layout

\begin_layout Standard
The largest gain, however, is as-yet unrealised: we need to eliminate the
 locale database.
 This is a large (200k) structure stored as inline read-only data which
 provides formatting information for different locales; however, it is only
 needed when calling date with certain format strings that print a locale-specif
ic representation.
 Its elimination would reduce the binary size by 80%.
 However in order to achieve this benefit we need to extend our analysis
 somewhat: see Future Work below for details.
\end_layout

\begin_layout Standard
The date program also presents some challenges to specialisation, requiring
 annotation in some places.
 The loops of both strftime and its wrapper contain a number of error exit
 paths, making it difficult to establish whether the loop should be peeled
 another iteration or whether this would simply inflate the output code
 size with specialised code that will usually be bypassed.
 We annotate these edges as unlikely, meaning the specialiser assumes that
 the loop will usually terminate for a different reason and goes on to explore
 further iterations (in fact the usual termination condition is reaching
 the end of the format string).
 We also annotate functions which the specialiser does not explore because
 they are not certain to be executed.
 Of the N annotations for the date program, M are of this kind and we expect
 these to become unnecessary as we improve the specialiser's exploration
 strategy.
\end_layout

\begin_layout Standard
A second problem is that the date program features a lot of difficult-to-analyse
 pointer arithmetic, mostly stemming from the stdio library.
 Rather than store indices and use these to index into arrays, the library
 stores pointers which it increments and decrements as the user calls stdio
 functions.
 These manifest in LLVM as getelementptr instructions, deriving one pointer
 from another, with a non-constant base address.
 These cases can be dealt with fully automatically, however: the specialiser
 is able to establish that the loops within fwrite and related functions
 always deal with pointers ultimately derived from a particular base object
 (a statically allocated buffer), and consequently these stdio functions
 do not present an insurmountable barrier to alias analysis and therefore
 further exploration of the program.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
We plan to improve the specialiser's exploitation of specialisation opportunitie
s, and to explore novel applications for a tool of this kind.
\end_layout

\begin_layout Standard
On the first matter, we intend to extend its notion of value slightly further
 by allowing instructions to be assigned range types, derived primarily
 from tests which dominate the instruction.
 This is an example of driving.
 In particular this extension will allow us to reduce code much more for
 all cases mentioned here by eliminating large pieces of read only data
 which the program can be proved never to access.
\end_layout

\begin_layout Standard
We also intend to develop the specialiser's exploration strategy much more
 in order to reduce the annotations required for programs such as those
 evaluated here to near-zero.
 In particular we intend to improve its ability to determine which functions
 and loops to consider in more detail by observing the data flow dependencies
 within the program, favouring functions and loops which block a lot of
 data flow paths, and we intend to improve its ability to analyse loops
 in order to recognise those such as strftime which could be established
 to always make forward progress through a buffer, allowing us to prove
 they will terminate and justify exploring in more depth even when exit
 edges remain alive.
\end_layout

\begin_layout Standard
Regarding applications we intend to explore using the specialiser in multi-proce
ss and multi-threaded environments.
 We envisage several interesting use cases:
\end_layout

\begin_layout Standard
* Specialisation with respect to inter-process communication: we could analyse
 two bitcode files in parallel, analysing BSD sockets calls using the same
 treatment as for open, and read system calls at present.
 This would be useful for embedded applications where a developer might
 want to eliminate dependency on a daemon such as gconf which they expect
 to return constant results in that fixed setting.
\end_layout

\begin_layout Standard
* MAKE IT EFFICIENT 
\begin_inset CommandInset citation
LatexCommand cite
key "sumii1999efficientonlinepe"

\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Partial evaluators have been developed for both functional languages such
 as Lisp 
\begin_inset CommandInset citation
LatexCommand cite
key "beckman1976lisp"

\end_inset

 and Scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "berlin1990scheme1,weise1991fusescheme"

\end_inset

, and for imperative languages including Fortran 
\begin_inset CommandInset citation
LatexCommand cite
key "baier1994fortran"

\end_inset

, C 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix,consel2004tour"

\end_inset

 and Java 
\begin_inset CommandInset citation
LatexCommand cite
key "affeldt2002javaruntime,schultz2003jspec,shali2011hybridpe"

\end_inset

.
 For a more complete roundup of partial evaluators see reviews 
\begin_inset CommandInset citation
LatexCommand cite
key "beckmann1996partial,jones1996introduction"

\end_inset

.
\end_layout

\begin_layout Subsection
C-Mix
\end_layout

\begin_layout Standard
The partial evaluators C-mix 
\begin_inset CommandInset citation
LatexCommand cite
key "makholm1999cmix2,andersen1994cmix"

\end_inset

 and Tempo 
\begin_inset CommandInset citation
LatexCommand cite
key "consel2004tour"

\end_inset

 have made the most progress in specialising complete C programs.
 C-mix targets the full C language; however, it conservatively residualises
 code featuring difficult-to-analyse constructions such as pointer arithmetic
 and type puns achieved by pointer casting or union types.
 It is an ahead-of-time, offline PE (see section 2), going so far as to
 emit its BTA results realised as an executable program, termed a generating
 extension, which takes concrete specialisation-time arguments and emits
 fully specialised programs.
 If multiple specialisations of a program are desired, specialising with
 respect to the same arguments but differing in their concrete values, this
 may be much faster than online PE such as ours which would require a full
 specialisation run for each different set of argument values.
\end_layout

\begin_layout Standard
As an offline PE with a monovariant BTA, it is conservative when selecting
 which statements and expressions can be evaluated at specialisation time:
 whilst it does specialise functions per static callsite, at an intraprocedural
 level it will residualise all uses of variables which are at any point
 assigned dynamic values or under dynamic control.
 Other limitations include a lack of support for malloc and other functions
 manipulating heap memory, the possibility of specialiser non-termination
 on source programs which themselves always terminate, and the need to annotate
 external functions' side-effects and global variables' visibility to other
 translation units.
 The latter limitation arises because most C programs are compiled by seperate
 compilation of both translation units within a program and pre-compiled
 libraries.
\end_layout

\begin_layout Standard
C-mix has been evaluated both by its creators, achieving up to 50% reduction
 in runtime at the cost of sometimes-significant code size increase specialising
 a 10KLOC raytracer with respect to its scene description, and by others
 
\begin_inset CommandInset citation
LatexCommand cite
key "jung2005cmix2user"

\end_inset

, achieving up to 60% code size reduction evaluating an operating system
 kernel with respect to its configuration.
\end_layout

\begin_layout Subsection
Tempo
\end_layout

\begin_layout Standard
Tempo is another offline PE, but unlike C-Mix is capable of operating both
 ahead of time and at runtime.
 Its BTA is more precise than that of C-Mix 
\begin_inset CommandInset citation
LatexCommand cite
key "hornof1997tempobta"

\end_inset

, permitting it to execute computations at specialisation time even when
 variables involved are sometimes under dynamic control, but it is nontheless
 a monovariant BTA at the intraprocedural level, meaning it conflates iterations
 of loops, and despite polyvariance at the interprocedural level it conflates
 recursive procedure calls in order to guarantee specialiser termination.
 
\end_layout

\begin_layout Standard
Unlike C-Mix, Tempo was explicitly designed for systems applications, and
 has been evaluated in many real-world scenarios, including specialising
 RPC serialisation routines with respect to the data type that will be serialise
d 
\begin_inset CommandInset citation
LatexCommand cite
key "mcnamee2001temporpcbpf"

\end_inset

, a Berkeley Packet Filter interpreter with respect to its program, and
 a Java bytecode interpreter with respect to its input program.
 
\end_layout

\begin_layout Standard
Whilst these applications are important successes, and exhibit Tempo's maturity
 as a practical tool, it shares C-Mix's limitations when dealing with seperate
 compilation and when dealing with heap-allocated memory: Tempo's alias
 analysis conflates all heap allocated memory 
\begin_inset CommandInset citation
LatexCommand cite
key "emami1994aa"

\end_inset

, meaning specialisation-time execution of loads and stores in that memory
 is effectively forbidden.
\end_layout

\begin_layout Subsection
Online PE
\end_layout

\begin_layout Standard
As an online PE, our specialiser's primary goal is maximum specialisation
 rather than to optimise efficiency of the specialisation process, in contrast
 to C-Mix and Tempo, both of which used an offline strategy.
 Online PEs have been developed for a functional subset of Scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "berlin1990scheme1,weise1991fusescheme"

\end_inset

, and for Prolog 
\begin_inset CommandInset citation
LatexCommand cite
key "sahlin1990mixtus"

\end_inset

.
 These systems boast large (greater than 10x) speedups applied to numerical
 kernels and toy programs respectively, but have not been evaluated on realistic
 whole programs.
 
\end_layout

\begin_layout Standard
Later online PEs targeted imperative languages including a subset Pascal
 
\begin_inset CommandInset citation
LatexCommand cite
key "meyer1999upascal"

\end_inset

 and full Java 
\begin_inset CommandInset citation
LatexCommand cite
key "shali2011hybridpe"

\end_inset

.
 The latter, named Civet, uses a hybrid approach in which the programmer
 manually annotates subsets of the program to be specialised and offline
 BTA is conducted to check the consistency of their annotations, before
 a full online PE is used at specialisation time.
\end_layout

\begin_layout Subsection
Runtime PE
\end_layout

\begin_layout Standard
PEs operating at runtime have the potential to exploit specialisation opportunit
ies not available to ahead-of-time PE, because all concrete parameters are
 available to them, enabling the PE to dynamically analyse and optimise
 for emergent situations which the programmer or user did not necessarily
 anticipate.
 On the other hand, runtime PEs are much more resource-constrained than
 ahead-of-time PEs because they offset any speedup to their target program
 against the cost of specialisation.
 
\end_layout

\begin_layout Standard
Runtime PEs often include an ahead-of-time BTA (
\begin_inset CommandInset citation
LatexCommand cite
key "consel1996temporuntime,khan2008runtimetempl"

\end_inset

) to reduce this cost as much as possible, reducing their runtime task to
 simply filling in pre-prepared executable templates.
 The Synthesis kernel 
\begin_inset CommandInset citation
LatexCommand cite
key "pu1988synthesis"

\end_inset

 achieved significant runtime reduction using hand-written templates for
 filesystem-operation system calls.
 Tempo (see above) can use the same BTA stage that drives its ahead-of-time
 specialiser to build templates for runtime specialisation, and was later
 combined with the Synthesis kernel to automatically generate and instantiate
 the templates which were previously produced by hand 
\begin_inset CommandInset citation
LatexCommand cite
key "pu1995synthetix"

\end_inset

.
\end_layout

\begin_layout Standard
Whilst the PEs above restrict their runtime phase to instantiating templates
 in the name of efficiency, some runtime specialisers such as DyC 
\begin_inset CommandInset citation
LatexCommand cite
key "grant2000dyc"

\end_inset

 and Dynamo 
\begin_inset CommandInset citation
LatexCommand cite
key "bala2000dynamo"

\end_inset

 also perform runtime peephole optimisation on their generated code.
 A runtime PE for Java 
\begin_inset CommandInset citation
LatexCommand cite
key "affeldt2002javaruntime"

\end_inset

 works at the Java bytecode level and so defers optimisation to the JIT
 compiler.
\end_layout

\begin_layout Subsection
Large Scale Specialisation
\end_layout

\begin_layout Standard
Several prior projects have attacked the problem of specialising entire
 pieces of software, or even entire systems.
 Both Charon 
\begin_inset CommandInset citation
LatexCommand cite
key "perianayagam2006charon"

\end_inset

 and a Ghent system based on Diablo 
\begin_inset CommandInset citation
LatexCommand cite
key "chanet2005system"

\end_inset

 aimed to specialise the Linux kernel with respect to a corpus of userspace
 programs that will be run, targeting embedded systems where the set of
 programs that can be run is tightly controlled.
 By working at the binary level they were forced to spend a great deal of
 effort disassembling and inferring high-level semantic information, and
 needed to act conservatively where that analysis was insufficient, but
 nontheless were able to eliminate unused system calls and consequent dead
 code.
 They also introduced specialised system calls when their userspace programs
 could be shown to frequently invoke them with particular parameters.
 Their specialisation of these calls was limited, however, by the fidelity
 of their disassembly and subsequent analysis.
\end_layout

\begin_layout Subsection
Whole Program Analysis and LLVM
\end_layout

\begin_layout Standard
LLVM is perfect for whole program analyses like ours because it provides
 tools to link translation units and libraries whilst retaining the high-level
 semantic information necessary for aggressive analysis and transformation.
 KLEE 
\begin_inset CommandInset citation
LatexCommand cite
key "cadar2008klee"

\end_inset

 is a program analysis tool which searches for program inputs which can
 cause crashes and other bugs by propagating value constraints through LLVM
 programs, similar to how our tool propagates possible value sets.
 Another attribute our work shares with KLEE is that we have both implemented
 or mocked up a subset of the POSIX API in order to allow specialisation
 and analysis, respectively, of programs including system calls.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "pldi2013"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
