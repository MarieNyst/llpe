#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{usenix}
\end_preamble
\options letterpaper,twocolumn,10pt
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
\size large
LLPE: A Practial Specialiser for LLVM Programs
\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

 {
\backslash
rm Christopher Smowton and Steven Hand}
\backslash

\backslash
   University of Cambridge
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Abstract
\end_layout

\begin_layout Standard
We present the design and prototype implementation of a specialiser for
 real-world large programs written in languages which can be compiled to
 LLVM bitcode, such as C and C++.
 It specialises whole programs with respect to a user-supplied command-line,
 environment, and/or filesystem image and produces a specialised program
 which is smaller and faster to execute.
 It improves LLVM bitcode using partial evaluation, a program transformation
 that combines the techniques of constant propagation, dead code elimination,
 loop peeling and procedure inlining.
 It supports almost all LLVM programs, including support for arbitrary pointer
 indirection, data reinterpretation and restricted pointer arithmetic.
\end_layout

\begin_layout Standard
We evaluate the specialiser on programs from the GNU coreutils suite compiled
 against uclibc, as well as the lightweight webserver nginx.
 We achieve code size reductions up to X% and runtime reductions up to Y%.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The software we use on a day-to-day is often much more general than it needs
 to be for the task for which it is employed.
 Specialised software can consume less memory, energy and execution time
 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

, but specialisation of large programs for a specific task is seldom seen
 in practice.
 This is because hand-specialising programs is time-consuming and error-prone,
 with the development and testing time likely to outweigh the resources
 saved running the specialised software (TODO: find a good citation for
 'reusing existing, general software is usually a good idea').
 By automating the specialisation process, specialisation can be turned
 from a task of weeks to one of hours, and therefore made practically applicable
 to everyday real-world programs.
\end_layout

\begin_layout Standard
Partial evaluation is a program transformation which can perform automated
 specialisation.
 In this paper, we present the design of a partial evaluator (PE) for real-world
-scale LLVM 
\begin_inset CommandInset citation
LatexCommand cite
key "lattner2004llvm"

\end_inset

 programs, called LLPE, which specialises whole programs with respect to
 command-line parameters, environment variables and/or a filesystem image.
 We aim for high accuracy and minimum user input into the specialisation
 process.
\end_layout

\begin_layout Standard
PEs must trade off between the cost of specialisation and how closely they
 can approximate theoretically optimal specialisation, called their accuracy.
 We target use cases where specialisation can be performed ahead-of-time,
 and a specialised program is expected to be used many times before it is
 re-specialised, and so performance of the specialised program is much more
 important than that of the specialiser.
\end_layout

\begin_layout Standard
Because we aim to automate the PE process entirely, we aggressively explore
 all possible paths of execution in the target program, restricted to ensure
 
\emph on
soundness
\emph default
 (the emitted program must be observationally equivalent to the input program,
 modulo specialised arguments) and 
\emph on
termination
\emph default
 of the specialiser.
 However because proving termination is difficult, we also degrade gracefully
 to support simple, easy-to-use annotations that provide hints when our
 PE would otherwise underspecialise the input program.
\end_layout

\begin_layout Standard
By targeting LLVM intermediate representation (IR), our PE can exploit many
 useful properties of the LLVM ecosystem.
 We can easily specialise whole programs consisting of more than one translation
 unit, including library code, without requiring user description of externals,
 since LLVM tools make it easy to produce final linked IR images which retain
 sufficient high-level semantic information for program transformations
 like PE.
 Due to the widespread availability of compilers targeting LLVM, we can
 also target programs written in many source languages, including C, Objective-C
, C++ and Haskell amongst others, as well as multi-lingual projects (e.g.
 a C++ program linking a pure C library).
\end_layout

\begin_layout Standard
We have implemented a prototype realising a large portion of our design.
 In section Blah we describe our implementation, along with the challenges
 we anticipate in fully realising our design.
 We evaluated our prototype on 3 programs in the GNU coreutils suite (10,000s
 of source lines of code, including libraries), and on the lightweight web
 server ngnix, producing code size reductions of up to X% and runtime improvemen
ts of up to Y%.
\end_layout

\begin_layout Subsection
Contributions
\end_layout

\begin_layout Standard
The contributions of this paper relative to prior work are:
\end_layout

\begin_layout Itemize
A design for a PE targeting LLVM IR, including a novel online PE algorithm
 that works by a form of abstract interpretation and a novel 
\begin_inset Quotes eld
\end_inset

storeless
\begin_inset Quotes erd
\end_inset

 approach to handling memory side-effects.
\end_layout

\begin_layout Itemize
To our knowledge, our support for specialisation with respect to state exposed
 via the POSIX system call API rather than as explicit arguments is novel
 in partial evaluation.
\end_layout

\begin_layout Itemize
We provide a user-customisable algorithm for assessing the cost of PE after
 analysis but before writing a specialised program, allowing the user to
 trade output program code size against performance.
\end_layout

\begin_layout Itemize
We evaluate the cost and benefit of specialisation applied to whole, real-world
 programs.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
It is common for very general software to be used where a more specialised
 program would have done the job.
 Fully featured web servers are used to serve static content; regular expression
 parsers are used when their search expression is so simple that it boils
 down to 
\family typewriter
strstr
\family default
; fully-featured databases with support for ACID transactions and clustering
 are used in applications that in fact only call for a single-user hash
 table.
 This usually happens out of expediency: the tool exists, is familiar to
 the user, definitely does the required job (despite doing many dozens of
 other things as well), and there is little motivation to invent a better
 solution when resources (CPU cycles, memory) are plentiful.
\end_layout

\begin_layout Standard
It is also common to need to employ such general-purpose, inefficient prototypes
 in a setting where resource consumption is important.
 This might be because the prototype will be run in a cloud computing environmen
t which is billed per CPU cycle or byte of memory consumed, or because the
 ultimate target is an embedded environment with physical resource restrictions,
 or because a network service became unexpectedly popular to the point that
 it taxes its host hardware.
 In such cases we'd like to use the same all-purpose tools we're familiar
 with, but we need to compromise to meet our resource budget.
 We could customise the software by hand, but the development and debugging
 costs of such modifications may be excessive.
 We could sacrifice functionality and use a system designed explicitly for
 restricted environments (such as trading in GNU Coreutils for 
\family typewriter
busybox
\family default
), but such an alternative might not be readily available, and the replacement
 is likely to have subtly different behaviour and bugs to the original,
 or may offer a restricted feature subset that is not convenient to our
 needs.
\end_layout

\begin_layout Standard
Using partial evaluation we can have our cake and eat it too: the existing,
 large program can be specialised with respect to invariants that we know
 about its operating context to produce a smaller, faster program that behaves
 identically to the original so long as the invariants are maintained and
 the specialiser is correct.
\end_layout

\begin_layout Subsection
Partial Evaluation
\end_layout

\begin_layout Standard
Partial evaluation (PE), also known as program specialisation or staged
 compilation, describes the evaluation of part of a program, usually assuming
 some specialisation conditions, and emission of a residual program which
 is observationally equivalent to the original so long as those specialisation
 conditions are obeyed.
\end_layout

\begin_layout Standard
As a trivial example, one could specialise the 
\family typewriter
printf
\family default
 function to assume that its first argument will be 
\family typewriter
"%d"
\family default
.
 Under this assumption, printf reduces to a function that prints a single
 integer as a decimal.
 The resulting code will be smaller, as printf's other output routines can
 be discarded, and faster to execute, because instructions that examine
 the format string can be evaluated ahead of time.
 The specialised function might be small enough to consider inlining, which
 will eliminate the cost of a call/return sequence entirely.
 The emitted specialisation of printf is equivalent to the original so long
 as the specialisation condition (that the first parameter is 
\family typewriter
"%d"
\family default
) is true.
\end_layout

\begin_layout Standard
PE of entire programs extends this idea by specialising with respect to
 the arguments supplied to the program's entry point (i.e.
 its command-line arguments or environment), as well as implicit parameters
 examined using system calls, such as the contents of the filesystem.
 Whilst specialisation conditions for internal functions can be proven by
 the specialiser (for example, it will never emit code using its specialised
 
\family typewriter
printf
\family default
 unless it is sure the parameters are appropriate), specialisation with
 respect to external state requires that we either depend on the user to
 obey those conditions (with undefined behaviour if they don't), or that
 the specialiser emits code to check those conditions (called guards).
 For example, if the 
\family typewriter
printf
\family default
 example above were to take its format string from a command-line argument,
 we would either note that calling with a different format string will lead
 to undefined behaviour or emit a guard which checks that the format string
 is as expected and exits otherwise.
\end_layout

\begin_layout Standard
PE can take place ahead of time (sometimes called static PE), in which specialis
ation conditions are specified in advance and a specialised program is produced
 but the specialiser plays no further role at runtime, or can take place
 at runtime (called a dynamic partial evaluator), in which the specialiser
 is present in the executable and generates code at hand-specified points,
 or in response to dynamic profiling of the executing code, akin to a just-in-ti
me compiler.
\end_layout

\begin_layout Standard
All PEs, when given an input program to specialise, must at some point determine
 which computations in that program should be evaluated at specialisation
 time (termed 
\emph on
static
\emph default
 statements or expressions) and which must be suspended until the specialised
 program is run (termed 
\emph on
dynamic
\emph default
).
 An online partial evaluator takes this decision when given both an input
 program and concrete values for some of its parameters; by contrast an
 offline partial evaluator decides based on the input program and a 
\emph on
division
\emph default
 of its arguments (a division specifies which arguments will be supplied
 at specialisation time, and which will be supplied at runtime), but 
\emph on
without
\emph default
 knowledge of the arguments' concrete values 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

.
\end_layout

\begin_layout Standard
Online PEs are generally more accurate but less efficient than offline PEs
 
\begin_inset CommandInset citation
LatexCommand cite
key "christensen2004offvsonline"

\end_inset

.
 We chose to implement an online PE, because we aim to produce highly specialise
d programs which we expect to re-specialise infrequently, meaning we value
 the efficiency of the specialised program more than that of the specialiser
 itself.
 
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
We present the design of LLPE, an ahead-of-time online PE for LLVM bitcode
 with optional guards.
 It combines well-known analyses using a novel specialisation strategy to
 produce a specialiser capable of processing real-world programs, surpassing
 previous work in the scale of its input programs and its coverage of the
 source language.
\end_layout

\begin_layout Standard
Our high-level design goals are as follows:
\end_layout

\begin_layout Itemize

\emph on
Soundness
\emph default
.
 We specialise programs using properties which we can establish for certain
 given the specialisation conditions, and make no further assumptions about
 the program's input or the behaviour of the target machine beyond those
 embodied in the LLVM specification and the target architecture if one is
 provided by the frontend compiler.
 Naturally the threat of bugs in the specialiser remains, but we seek the
 minimise the risk by using well-exercised kernels from core LLVM transformation
 passes as much as possible.
\end_layout

\begin_layout Itemize

\emph on
Accuracy
\emph default
.
 Unless all program parameters are available at specialisation time, we
 will have to residualise some instructions to be executed at runtime.
 We aim to approach the theoretical maximum number of instructions executed
 ahead of time (that is, to be highly 
\emph on
accurate
\emph default
) at the expense of the efficiency of LLPE itself, because we target situations
 where the benefits of specialisation are large and the target program is
 expected to be executed many times before respecialisation is needed, and
 LLPE is run ahead-of-time and so is not time-critical.
\end_layout

\begin_layout Itemize

\emph on
Scalability
\emph default
.
 In order to effectively specialise large programs, it is necessary to prove
 facts across a large codebase: for example, to show that a global variable
 accessed late in execution still has its initialiser value requires us
 to establish that no intervening instruction has written to that variable.
 We achieve scalability using multiple levels of analysis, characterising
 functions' and loops' behaviour first in a context-insensitive manner,
 then again considering their parameters, and then finally, if necessary,
 considering their dynamic execution context.
 This enables us to abbreviate program analysis by dealing in entire functions
 and loops wherever possible, only considering their fine details where
 necessary.
\end_layout

\begin_layout Itemize

\emph on
Usability
\emph default
.
 Inevitably, automatic analysis will sometimes fail to fully exploit the
 available information and produce suboptimal output.
 For these cases we support easy to understand and use annotations, allowing
 the user to provide extra guidance without threatening correctness.
\end_layout

\begin_layout Itemize

\emph on
Practicality
\emph default
.
 We target LLVM bitcode in order to support programs written in many low-level
 programming languages, including C and C++, whilst providing a source language
 whose semantics are well specified and which is small enough that broad
 coverage is practical.
\end_layout

\begin_layout Standard
We will describe the detailed design of our specialiser starting with a
 simple core design which is then augmented to take advantage of more specialisa
tion opportunities and to improve efficiency.
 We use a series of illustrative example programs which are expressed in
 C-like SSA-form pseudocode, with an explicit 
\family typewriter
phi
\family default
 operation that merges values at control flow merge points.
\end_layout

\begin_layout Subsection
Concrete Online PE
\end_layout

\begin_layout Standard
LLPE, as most online PEs, is structured similar to an interpreter.
 Starting at the program entry point, it symbolically executes each LLVM
 instruction, calculating its result if its arguments are known to the PE
 or leaving the instruction unresolved (and therefore to be residualised
 in the specialised program) otherwise.
 For the time being we will only consider instructions to have a known,
 concrete result (of any LLVM data type, including pointers) or to be entirely
 unknown, but we will lift this restriction later.
\end_layout

\begin_layout Standard
Like an ordinary interpreter, when LLPE encounters a call instruction it
 recurses to evaluate the called function; similarly when loops are controlled
 by a static termination condition it will iterate through the loop at specialis
ation time, analysing the loop body individually for each iteration.
 To phrase these properties another way, our analysis of the source program
 is 
\emph on
context-sensitive
\emph default
 and 
\emph on
flow-sensitive
\emph default
.
\end_layout

\begin_layout Standard
We diverge from ordinary interpretation when we encounter a conditional
 branch which cannot be decided at specialisation time (i.e.
 a 
\emph on
dynamic branch
\emph default
).
 In this case both successor basic blocks need to be residualised using
 our usual interpretation method.
\end_layout

\begin_layout Standard
LLVM IR is for the most part in Single Static Assignment (SSA) form, which
 means that there is usually no need to determine the 'current' value of
 a variable, as data flow is explicitly represented in the IR.
 As such, our interpreter does not need to maintain a store for these values.
 LLVM memory access, on the other hand, is it not in SSA form.
 We resolve reads from memory by walking backwards through the program's
 control-flow graph (CFG) looking for store instructions accessing the same
 memory.
\end_layout

\begin_layout Standard
Whilst most PEs perform alias analysis before analysing the source program
 (for example, Tempo 
\begin_inset CommandInset citation
LatexCommand cite
key "consel1996tempobasic"

\end_inset

 and C-Mix 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

 both adopt this approach), we determine pointer aliases on the fly, using
 addresses calculated earlier in interpretation.
 This improves LLPE's accuracy over PEs conducting the two analyses seperately,
 because PE can kill the instructions that cause potential aliasing, which
 in turn can lead to better PE results.
\end_layout

\begin_layout Standard
At control flow merges, most PEs must determine whether the two possible
 predecessors could have resulted in contradictory stores and merge the
 two (see for example Tempo or JSpec 
\begin_inset CommandInset citation
LatexCommand cite
key "schultz2003jspec"

\end_inset

); however, for SSA identifiers a merge is explicitly indicated in LLVM
 IR by a 
\family typewriter
phi
\family default
 instruction.
 We interpret these by checking whether all live blocks would feed it the
 same concrete value; if not we leave it with an unknown value.
 Contradictory values stored to memory are naturally handled by our approach
 to resolving memory reads.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% LaTeX chokes on lstlisting within subfloat?
\end_layout

\begin_layout Plain Layout


\backslash
newsavebox{
\backslash
figonea}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lrbox}{
\backslash
figonea} % Store first listing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

int32 main() {
\end_layout

\begin_layout Plain Layout

	int32 a = 7;
\end_layout

\begin_layout Plain Layout

	int32* b = &a;
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		i = phi(0, k);
\end_layout

\begin_layout Plain Layout

		j = f(b);
\end_layout

\begin_layout Plain Layout

		k = i + j;
\end_layout

\begin_layout Plain Layout

		exit_cond = k < 10;
\end_layout

\begin_layout Plain Layout

	} while(exit_cond)
\end_layout

\begin_layout Plain Layout

	return k;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int32 f(int32* x) {
\end_layout

\begin_layout Plain Layout

	ret = *x;
\end_layout

\begin_layout Plain Layout

	*x = 5;
\end_layout

\begin_layout Plain Layout

	return ret;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{lrbox}
\end_layout

\begin_layout Plain Layout


\backslash
newsavebox{
\backslash
figoneb}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lrbox}{
\backslash
figoneb} % Store second listing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

int32 main() {
\end_layout

\begin_layout Plain Layout

	int32 a = 7;
\end_layout

\begin_layout Plain Layout

	int32* b = &a;
\end_layout

\begin_layout Plain Layout

	i_iter1 = 0;
\end_layout

\begin_layout Plain Layout

	ret_f_iter1 = 7;
\end_layout

\begin_layout Plain Layout

	a = 5;
\end_layout

\begin_layout Plain Layout

	j_iter1 = 7;
\end_layout

\begin_layout Plain Layout

	k_iter1 = 7;
\end_layout

\begin_layout Plain Layout

	exit_cond_iter1 = false;
\end_layout

\begin_layout Plain Layout

	i_iter2 = 7;
\end_layout

\begin_layout Plain Layout

	ret_f_iter2 = 5;
\end_layout

\begin_layout Plain Layout

	a = 5;
\end_layout

\begin_layout Plain Layout

	j_iter2 = 5;
\end_layout

\begin_layout Plain Layout

	k_iter2 = 12;
\end_layout

\begin_layout Plain Layout

	exit_cond_iter2 = true;
\end_layout

\begin_layout Plain Layout

	return 12;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{lrbox}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usebox{
\backslash
figonea}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Before LLPE
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:eg1pre"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usebox{
\backslash
figoneb}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
After LLPE
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:eg1post"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example program featuring a loop, calls and memory operations, before
 and after application of LLPE.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To give an example of LLPE as described so far, Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:eg1pre"

\end_inset

 shows a program involving 2 functions, 
\family typewriter
main
\family default
 and 
\family typewriter
f
\family default
, and Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:eg1post"

\end_inset

 shows the values LLPE computes for each instruction and the straightened
 program structure after the calls to 
\family typewriter
f
\family default
 are inlined the loop unrolled, but before dead instructions are removed.
 As all instructions are either evaluated to constants or dead (without
 users) when constant instructions are disregarded, the output program is
 simply 
\family typewriter
return 12
\family default
.
 Note that we are able to resolve the 
\family typewriter
ret = *x
\family default
 instruction in 
\family typewriter
f
\family default
 as we can easily show it is fed by 
\family typewriter
a
\family default
's initialiser 
\family typewriter
7
\family default
 and 
\family typewriter
a = 5
\family default
, respectively, at the first and second call to 
\family typewriter
f
\family default
.
\end_layout

\begin_layout Subsubsection
Termination
\end_layout

\begin_layout Standard
If our approach so far were applied naively, there are many input programs
 that would cause infinite PE.
 For example, a potentially infinite recursive call to a function, or a
 loop controlled by a dynamic branch, could result in our specialising an
 infinite number of procedure calls or basic blocks respectively, even if
 the infinite recursion or loop would not be entered at runtime.
\end_layout

\begin_layout Standard
To ensure PE termination, we only permit potentially infinite exploration
 such as this on paths which are certain to be executed at runtime.
 To be precise, we investigate loops only if their header block post-dominates
 the program exit, and stop iterating if we find that an iteration has live
 exit edges.
 Calls are not explored if they would enter a recursion (that is, if another
 call to the same function is on the stack) unless the basic block containing
 the call instruction post-dominates the caller's exit block.
 Thus the PE can only enter an infinite loop if the program under specialisation
 would do so as well, which is usually regarded as acceptable behaviour
 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

 for a partial evaluator.
 Nontheless if a certain path 
\emph on
is
\emph default
 certain to execute we explore its control flow as aggressively as possible.
\end_layout

\begin_layout Subsubsection
Guards
\end_layout

\begin_layout Standard
If a specialised program is executed in an environment that doesn't match
 the assumptions made at specialisation time, undefined behaviour can result.
 For example, if we specialise 
\family typewriter
printf
\family default
 with respect to the format string 
\family typewriter

\begin_inset Quotes eld
\end_inset

%d
\begin_inset Quotes erd
\end_inset


\family default
 and then call it with a different format string at runtime, several results
 are possible.
 The specialised function might work as expected, it might ignore the runtime
 argument outright, or it might combine the two behaviours unpredictably.
\end_layout

\begin_layout Standard
To avoid this undefined behaviour we can optionally synthesise a guard.
 In order to check environment variables and command-line parameters, we
 simply precede the specialised program with a check that the argument or
 variable matches that which was provided at runtime.
\end_layout

\begin_layout Standard
Our guards are optional because there are some contexts when we can absolutely
 guarantee the arguments are as expected and so the guard is useless, for
 example if we are specialising programs for an embedded system which will
 run software which is fixed and entirely under our control.
\end_layout

\begin_layout Subsection
System Call Support
\end_layout

\begin_layout Standard
We support a subset of system calls commonly used to import information
 that constitutes a specialisation condition, such as the contents of the
 filesystem, and understand file descriptors as first-class objects.
 We establish the sequence of system calls operating on a file descriptor
 by trying to find a unique predecessor call for each such system call,
 thus constructing a chain of operations leading from an 
\family typewriter
open
\family default
 call to one or more 
\family typewriter
close
\family default
 calls.
 We track a file descriptor's current file position along with the descriptor,
 and if we are able to prove the file and position going into a 
\family typewriter
read
\family default
 call we can evalute reads from its buffer at specialisation time.
 We can completely eliminate VFS system calls if we can identify and resolve
 every use of an 
\family typewriter
open
\family default
 call.
 
\end_layout

\begin_layout Standard
The file system contents might change after specialisation but before, or
 during, runtime.
 We must synthesise a guard to check that (a) the file has not been changed
 since specialisation, and (b) the file is used consistently throughout
 the program, even if it changes whilst the specialised program is in execution,
 in a way that matches the unspecialised program's behaviour.
\end_layout

\begin_layout Standard
We also hard-code knowledge of the side-effects of other system calls: for
 example, we note that 
\family typewriter
clock_gettime
\family default
 writes through both of its arguments and may 
\family typewriter
errno
\family default
 but has no other effects, even though of course we can't use the value
 of the system clock at specialisation time.
\end_layout

\begin_layout Subsection
Partially Dynamic Values
\end_layout

\begin_layout Standard
A significant limitation of the design as described so far is that it assigns
 each instruction either a concrete result (a constant or known pointer)
 or else assumes the instruction could have any result at all, even if its
 range remains limited: for example, according to LLVM semantics a pointer
 derived from another by pointer arithmetic must continue to point to the
 same allocated object (global variable, stack allocation or 
\family typewriter
malloc
\family default
 call).
 Knowing that a pointer addresses a particular object is very useful, even
 if its exact address is unknown, because a write through a completely unknown
 pointer potentially alters all of memory and prevents us from resolving
 any load that might be affected by it.
 To address this limitation, we extend our notion of instruction results
 to include two new kinds of information: 
\emph on
value sets
\emph default
, and 
\emph on
fuzzy pointers
\emph default
.
 
\end_layout

\begin_layout Standard
LLPE can resolve an instruction to a 
\emph on
set
\emph default
 of result values.
 These are produced when a 
\family typewriter
phi
\family default
 instruction has several live incoming values, when a 
\family typewriter
select
\family default
 instruction (which functions like C's ternary 
\family typewriter
x ? y : z
\family default
 operator, and is written as such in our examples) has an unknown first
 operand, or when a read from memory might receive conflicting but known
 definitions.
 Arithmetic and bitwise operations can be assigned value sets if one or
 more of their operands have been assigned sets: for example, 
\family typewriter
{1, 2}
\family default
 + 
\family typewriter
{4, 8}
\family default
 evaluates to 
\family typewriter
{5, 6, 9, 10}.
\end_layout

\begin_layout Standard
In effect, tracking value sets in this way is similar to specialisation
 by continuations used by some offline PEs: these handle control flow merges
 by specialising the merge block for both possible predecessors (for example,
 C-Mix's treatment of the mergepoint after an 
\family typewriter
if
\family default
 / 
\family typewriter
else
\family default
 block 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

int32 main(int32 unknown) {
\end_layout

\begin_layout Plain Layout

	test = (unknown == 1);	// ?
\end_layout

\begin_layout Plain Layout

	vague = test ? 0 : 1;	// {0, 1}
\end_layout

\begin_layout Plain Layout

	certain = vague & 2;	// 0
\end_layout

\begin_layout Plain Layout

	return certain;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example program illustrating value sets: whilst 
\family typewriter
vague
\family default
 might take more than one value, 
\family typewriter
certain
\family default
 is nontheless assigned a single value.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:valset"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:valset"

\end_inset

 we give an example showing how tracking value sets per instruction can
 improve specialisation opportunities, in which a set is created but later
 resolved into a single value by masking out the uncertainty.
 This limits the scope of the uncertainty implied by dynamic parameter 
\family typewriter
unknown
\family default
.
 In order to avoid an explosion in the time and space needed for specialisation,
 once a value set grows larger than a user-controllable threshold it is
 considered wholly dynamic (i.e.
 we assume it may take any value, as for an instruction with no result calculate
d).
 This threshold can be adjusted to trade memory consumption for quality
 of specialisation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

int32 main(int32 dyn) {
\end_layout

\begin_layout Plain Layout

	int32 x[10];
\end_layout

\begin_layout Plain Layout

	int32 y = 1;
\end_layout

\begin_layout Plain Layout

	certain_ptr = x + 5;  // &(x[5])
\end_layout

\begin_layout Plain Layout

	fuzzy_ptr = x + dyn;  // &(x[?])
\end_layout

\begin_layout Plain Layout

	*certain_ptr = 2;
\end_layout

\begin_layout Plain Layout

		// Modifies x[5] only
\end_layout

\begin_layout Plain Layout

	*fuzzy_ptr = 3;
\end_layout

\begin_layout Plain Layout

		// Modifies entire array
\end_layout

\begin_layout Plain Layout

	unresolved = *certain_ptr;
\end_layout

\begin_layout Plain Layout

		// ?.
 Store of 3 interferes
\end_layout

\begin_layout Plain Layout

	resolved = y;
\end_layout

\begin_layout Plain Layout

		// 1.
 No store interferes
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example program illustrating fuzzy pointers: We know 
\family typewriter
fuzzy_ptr
\family default
 points somewhere in the array 
\family typewriter
x
\family default
, preventing us from resolving 
\family typewriter
*certain_ptr
\family default
 but providing enough information that we know 
\family typewriter
y
\family default
 is unmodified at the end.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:fuzzyptr"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A special case of a value set is a 
\emph on
fuzzy pointer
\emph default
: this is a pointer whose base object is known, but whose offset within
 that object is not.
 In figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fuzzyptr"

\end_inset

 we see a known pointer is indexed by a dynamic offset and then stored to.
 Without a fuzzy pointer association for the resulting pointer 
\family typewriter
fuzzy_ptr
\family default
 we would need to assume that the store operation alters all memory, but
 knowing its base object is 
\family typewriter
x
\family default
 we can constrain the write's side-effects and permit resolution of reads
 from different objects such as 
\family typewriter
y
\family default
.
\end_layout

\begin_layout Standard
Value sets and fuzzy pointers can be combined to produce a value which notionall
y points to one of several possible objects with an unknown offset.
 This value may alias another pointer if any of its set of bases may alias.
\end_layout

\begin_layout Standard
Previous PEs also needed to constrain the side-effects of store operations
 for the same reason, typically achieved by an alias analysis pass before
 PE as described in section 3.1.
 In this context a set of fuzzy pointers would be called a pointer's 
\emph on
points-to set
\emph default
.
 The advantage of our approach is that we take the results of interpretation
 so far into account when calculating points-to sets and so can find smaller
 sets, constraining side-effects more and blocking further specialisation
 less.
\end_layout

\begin_layout Standard
Instructions whose calculated values remain sets or fuzzy pointers at the
 end of specialisation are residualised in the output program like those
 with unknown results.
\end_layout

\begin_layout Subsection
Dynamic Loops and Calls
\end_layout

\begin_layout Standard
Another limitation of our design described so far is that because we try
 to establish values for instructions in loops on a per-iteration basis,
 and we only explore the next iteration when we are certain the loop will
 iterate, our progress will be severely limited when the input program contains
 a loop whose iteration count cannot be statically established.
 We now expand our analysis of loops to try to establish both per-iteration
 values and invariant values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=3"
inline false
status open

\begin_layout Plain Layout

int32 main(int32* p, int32* end) {
\end_layout

\begin_layout Plain Layout

	int32 x = 5;
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		ptr = phi(p, next_ptr)	// &(p[?])
\end_layout

\begin_layout Plain Layout

		(*ptr) = 0;
\end_layout

\begin_layout Plain Layout

		next_ptr = ptr + 1;		// &(p[?])
\end_layout

\begin_layout Plain Layout

		exit = (next_ptr == end);	// ?
\end_layout

\begin_layout Plain Layout

	} while(!exit)
\end_layout

\begin_layout Plain Layout

	return x;						// 5
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example program illustrating the value of loop invariant analysis.
 Whilst we can't explore every iteration of the unbounded loop, we establish
 
\family typewriter
ptr
\family default
 and 
\family typewriter
next_ptr
\family default
 point into 
\family typewriter
p
\family default
 as an invariant, and external 
\family typewriter
p
\family default
 must differ from local 
\family typewriter
x
\family default
.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:unboundloop"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:unboundloop"

\end_inset

 we show an unbounded loop that writes through some input buffer.
 Our simple strategy of following the program's dynamic execution flow like
 an interpreter is inadequate here, because we don't know how many times
 the loop will iterate.
 Instead, we consider the loop at two different scales: we try to investigate
 each iteration, as well as to establish invariants regarding the loop body.
 The per-iteration (flow-sensitive) investigation for this loop will fail
 when it can't decide if 
\family typewriter
exit
\family default
 is true.
 The invariant analysis, on the other hand, proves that only the input buffer
 is modified, and therefore 
\family typewriter
x
\family default
 is not modified.
\end_layout

\begin_layout Standard
Our loop invariant analysis includes considering function calls within an
 invariant context.
 For example, if the program in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:unboundloop"

\end_inset

 defined a trivial function 
\family typewriter
f(x, y) { *x = y; }
\family default
 and called 
\family typewriter
f(ptr, 0)
\family default
 within the loop, we would draw the same conclusions about the loop's side-effec
ts.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:callinloop"

\end_inset

 shows a more complex example program that illustrates how our loop invariant
 analysis investigates calls and subloops nested within the loop under considera
tion.
 We are able to establish as an invariant of the loop in 
\family typewriter
main
\family default
 that every call to 
\family typewriter
bset
\family default
 only modifies the array 
\family typewriter
buf
\family default
 by showing that for every call, and every iteration of the loop in 
\family typewriter
bset
\family default
, 
\family typewriter
this_p
\family default
 points into buf.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout
void main(int32 unk) {
\end_layout

\begin_layout Plain Layout
	int32 nbytes = unk * unk;
\end_layout

\begin_layout Plain Layout
	int8 buf[nbytes];
\end_layout

\begin_layout Plain Layout
	int8* ptr = buf;
\end_layout

\begin_layout Plain Layout
	do {
\end_layout

\begin_layout Plain Layout
		c = phi(0, next_c);
\end_layout

\begin_layout Plain Layout
		bset(&ptr, unk);
\end_layout

\begin_layout Plain Layout

			// Only modifies buf
\end_layout

\begin_layout Plain Layout
		next_c = c + 1;
\end_layout

\begin_layout Plain Layout
		exit = (next_c == unk);
\end_layout

\begin_layout Plain Layout
	} while (!exit);
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

void bset(int8* p, int32 n) {
\end_layout

\begin_layout Plain Layout

	end = p + n;				
\end_layout

\begin_layout Plain Layout

		// &(buf@main[?])
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		this_p = phi(p, next_p);	
\end_layout

\begin_layout Plain Layout

			// &(buf@main[?])
\end_layout

\begin_layout Plain Layout

		*this_p = 0;
\end_layout

\begin_layout Plain Layout

		next_p = this_p + 1;			
\end_layout

\begin_layout Plain Layout

			// &(buf@main[?])
\end_layout

\begin_layout Plain Layout

		exit = (next_p == end);
\end_layout

\begin_layout Plain Layout

	} while (!exit);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example program illustrating exploring a function in a loop-invariant
 context.
 We successfully prove that every call to 
\family typewriter
bset
\family default
 within the left-hand loop writes only to the buffer 
\family typewriter
buf
\family default
 declared in 
\family typewriter
main
\family default
, limiting the side-effects of the unbounded loop.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:callinloop"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike all scenarios considered so far, reasoning about unbounded loops
 requires LLPE to resolve circular dependencies between instructions, such
 as 
\family typewriter
ptr
\family default
 and 
\family typewriter
next_ptr
\family default
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:unboundloop"

\end_inset

.
 We resolve the dependency using a standard fixpoint method, repeatedly
 lowering in-loop instructions' results precision until a consistent solution
 if found.
 Lowering precision here means adding more values to a set-typed result,
 or downgrading an exact pointer to a fuzzy pointer, or replacing any result
 with an entirely unknown value.
 This process always terminates, because value sets have an upper size limit,
 meaning each value can only be downgraded a finite number of times, and
 a finite number of instructions are considered.
\end_layout

\begin_layout Subsection
Context-insensitive Analysis
\end_layout

\begin_layout Standard
Our design as elaborated thus far is effective, but inefficient.
 In part this is because functions called in many different contexts are
 explored once per dynamic invocation.
 This may be useful if we are looking to establish their dynamic results,
 but often we are only interested in their side-effects, for example because
 their parameters are dynamic and so we are solely concerned with preventing
 them from obstructing memory operations that cross the call site.
 To make our program analysis faster, and save the memory that would be
 consumed exploring the function's effects at every callsite, we introduce
 a context-insensitive characterisation of functions' memory side-effects
 that is calculated the first time a function's side-effects present an
 obstacle to specialisation.
\end_layout

\begin_layout Standard
We calculate for each function a set of modified locations, defined in terms
 of the function's pointer-typed arguments, global variables and escaping
 allocation calls (calls which have the LLVM 
\begin_inset Quotes eld
\end_inset

noalias
\begin_inset Quotes erd
\end_inset

 attribute attached to their return value, which binds them to return a
 fresh pointer; such calls include 
\family typewriter
malloc
\family default
 as well as custom allocators obeying a similar contract).
 The function's set of side-effects is calculated by running LLPE algorithm
 in the restricted context of the function under investigation, regarding
 pointer-typed arguments as first-class objects.
\end_layout

\begin_layout Standard
Sub-calls to other functions are represented as an inclusion along with
 a substitution: for example, if function f has two pointer-typed parameters,
 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
, and modifies 
\family typewriter
x
\family default
 but then calls itself recursively with the parameters reversed, we represent
 it as modifying 
\family typewriter
x
\family default
, plus its own modification set under the substitution 
\family typewriter
[x/y, y/x]
\family default
.
 For this purpose allocation instructions are represented as static callsites.
 Once all functions are so characterised, we have a recurrence relation
 between functions' modification sets.
 We solve by iterating the inclusion and substitution of other functions'
 sets of modified locations.
 This is guaranteed to terminate because there are a finite number of arguments,
 global variables and static allocation sites in the program, and a finite
 number of functions under consideration, and each step can only make modificati
on sets larger or terminate the algorithm.
\end_layout

\begin_layout Standard
The upshot of this pre-pass is that load forwarding across a call to a function
 which has been established to have simple effects can proceed without needing
 to investigate the function at each callsite.
 We investigate the function at each callsite regardless if we have concrete
 values for its arguments, since these may provide specialisation opportunities,
 or reduce its side-effects further.
\end_layout

\begin_layout Subsection
Program Annotations
\end_layout

\begin_layout Standard
For any specialisation algorithm there will be programs which present specialisa
tion opportunities the analysis does not discover.
 LLPE might for example fall short of ideal specialisation because it does
 not analyse a call or loop iteration because of the limits on exploration
 described in section 3.1.1, put in place to ensure PE termination.
 We might also overestimate the memory side-effects of a section of code,
 either because we did not analyse enough of its calls and loops to fully
 characterise its effects, or because its effects were too complex to describe
 and we were compelled to fall back to supposing it writes all of memory.
 To address both these cases, we support simple, expressive program annotations
 which the user can apply to improve specialisation results.
 The available annotations are:
\end_layout

\begin_layout Itemize

\emph on
Assume edge taken
\emph default
: this authorises the specialiser to analyse calls and loops downstream
 of the assumed edge as aggressively as if the edge was certain to be taken.
 It does not render the output incorrect if the branch goes the other way
 at runtime, but could cause PE non-termination.
 This annotation is useful if the specialiser is reluctant to explore loop
 iterations due to an exit edge which remains alive but which the programmer
 knows is unlikely to be taken, e.g.
 an exit edge dealing with memory allocation failure.
\end_layout

\begin_layout Itemize

\emph on
Expected exit edge
\emph default
: of a loop, this nominates a particular edge as the expected way to leave
 a loop, authorising the PE to investigate the next iteration as soon as
 the nominated edge is killed in the current iteration.
 A more aggressive version of the 
\emph on
assume edge taken
\emph default
 annotation, this should be used for loops which may exit on many unusual
 error conditions, but which normally have a known iteration count.
\end_layout

\begin_layout Itemize

\emph on
Always/never explore
\emph default
: override the specialiser's heuristics and always/never explore calls to
 a particular function.
\end_layout

\begin_layout Standard
In discussing our evaluation in section 6 we describe how and why these
 annotations were used in practice.
 We anticipate significantly reducing the need for annotations as our heuristic
 analysis improves, and describe this in section 7.
\end_layout

\begin_layout Subsection
Adaptive program exploration
\end_layout

\begin_layout Standard
Once we have analysed the entire program, we are now faced with a standard
 problem for PEs: was our specialisation worth it? When we have analysed
 calls and loops in the program, should we replace them with specialised
 versions, perhaps inlined or unrolled into their parent context, or leave
 them alone to avoid an explosion in code size?
\end_layout

\begin_layout Standard
We use a simple, user-customisable metric to decide which calls and loops
 should ultimately be residualise.
 The cost of peeling loop iterations or specialising functions to their
 call site is that by generating extra static instructions we will make
 the specialised program larger.
 This will certainly fill more space on disk and take longer to load into
 memory, either at startup or as pages are faulted in.
 It may also take longer to execute due to i-cache effects.
 On the other hand, if we do peel a loop or specialise a function, we will
 save the time spent executing instructions which could be evaluated at
 specialisation time.
 We weight these competing costs by user-supplied coefficients, so that
 the basic benefit score for specialising a loop or call is (a * code size
 increase) + (b * instructions eliminated), with a and b varied to vary
 the importance attached to the two factors.
\end_layout

\begin_layout Standard
An additional cost of leaving a function unspecialised or a loop unpeeled
 is that this prevents us from specialising any nested loops or calls.
 Therefore when deciding which loops and calls to specialise we walk the
 tree of loops and calls from the bottom up, first calculating benefit scores
 for loops and calls without children, then for their parents, taking into
 account that declining to specialise a parent will remove the benefit of
 the child.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
We have implemented a prototype that includes most features of our design.
 We have not yet implemented the context-insensitive analysis step, which
 we approximate by investigating every call-site independently at the cost
 of some analysis time and memory.
 We also defer implementing automatic guards to future work, but describe
 out planned implementation in Section 6.
\end_layout

\begin_layout Standard
LLPE is implemented as an LLVM 2.8 program analysis/transformation pass.
 We use and adapt many existing LLVM analyses and transformations, including
 their implementation of sparse conditional constant propagation (SCCP),
 their basic alias analysis, and their loop peeling and function inlining
 utilities.
 
\end_layout

\begin_layout Subsection
Implementing PE
\end_layout

\begin_layout Standard
We assume that all functions used in the PE input program are defined (i.e.
 the function body is available for analysis), with the exception of system
 calls.
 This is typically achieved by running the specialiser against a fully staticall
y linked program; however LLPE does not in principle preclude using shared
 objects in the final binary, as library functions could be externalised
 post-analysis and dynamically re-linked at runtime.
 We do not currently implement this functionality, however.
\end_layout

\begin_layout Standard
To specialise a program we start at a nominated entry function (for C programs
 this should be 
\family typewriter
libc_main
\family default
 rather than 
\family typewriter
main
\family default
, to take library initialisation into account), then walk the program's
 interprocedural control flow graph (CFG) evaluating instructions as described
 in our design above.
\end_layout

\begin_layout Standard
In parts of the program that can be topologically ordered (i.e.
 acyclic subgraphs of the CFG) we visit basic blocks in topological order
 to ensure that all instructions are evaluated after their arguments.
\end_layout

\begin_layout Standard
In cyclic parts of the program we track the dependencies between instructions,
 re-analysing each whenever its result may have changed.
 Normal instructions depend on their arguments, 
\family typewriter
phi
\family default
 instructions depend on their arguments and the CFG (i.e.
 they are re-evaluated if the local CFG changes), memory reads depend on
 writes that may define their result and the CFG.
\end_layout

\begin_layout Standard
We represent the program as a tree of 'integration contexts'.
 Each context corresponds to a dynamic function invocation or loop iteration,
 and assigns result values to instructions in that scope.
 Figure 7 shows part of the tree of integration contexts that would be produced
 investigating the example program shown in figure 1.
 Note that seperate contexts are created for the invocation of 
\family typewriter
f
\family default
 per iteration, rather than sharing one and conflating their results, correspond
ing to our strategy of maximally polyvariant analysis to achieve high accuracy.
 These contexts provide a convenient way to name a specific execution of
 an instruction, which we use to refer to a particular dynamic stack or
 heap allocation, rather than conflating allocations at a particular callsite.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename integrator-diagrams/fig7.svg
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Excerpt from the tree of integration contexts produced analysing the program
 in Figure 1.
 Iterations after 3 are omitted.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To describe loops in the CFG we use LLVM's standard 
\family typewriter
loops
\family default
 analysis, which constructs a tree of loops each of which is characterised
 by a header block which dominates the rest of the loop, and which is unique
 (i.e.
 the block is not also the header of another loop), and a single backedge.
 
\family typewriter
for
\family default
 and 
\family typewriter
while
\family default
 loops have this structure, but more complicated loop structures can be
 built using source language features such as C's 
\family typewriter
goto
\family default
 instruction, or may be emitted by compilers even if the user's code is
 simple: for these cases we preprocess the program using a somewhat augmented
 version of LLVM's standard 
\family typewriter
loopsimplify
\family default
 pass, which automatically simplifies all cyclic CFGs to fit this tree-of-simple
-loops form.
\end_layout

\begin_layout Standard
After LLPE has completely analysed the target program, we determine which
 loops and calls to peel and inline as described in section 3.7, before using
 LLVM's standard loop peeling and procedure inlining utilities to generate
 the specialised program.
 We do not currently emit any code until the program has been completely
 analysed, so that we can postpone the decision about whether early parts
 of the program are worth specialising until we have seen whether the informatio
n we discovered had beneficial results later on.
 This means that we must be able to store the complete graph of integration
 contexts in memory, which limits the scale of program we can currently
 handle; however we do not expect it to be difficult to scale up to larger
 programs by writing intermediate specialisation results to disk.
\end_layout

\begin_layout Subsection
Language Coverage
\end_layout

\begin_layout Standard
The current LLPE implementation achieves very high coverage of the LLVM
 intermediate language.
 We support many language constructs which are typically omitted from PEs
 because they are too difficult to implement (e.g.
 C-Mix omits all treatment of heap memory 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

, and JSpec conflates all objects allocated at a call-site for lack of names
 for individual allocations 
\begin_inset CommandInset citation
LatexCommand cite
key "schultz2003jspec"

\end_inset

).
\end_layout

\begin_layout Standard
Specifically, we are able to specialise programs featuring:
\end_layout

\begin_layout Itemize
Pointer arithmetic, so long as it is restricted to addition, subtraction,
 comparison, and examination of the lower bits of a pointer that are determined
 by its alignment.
 Pointers can be compared arbitrarily with other pointers that have a common
 base object, and compared for equality whether they have a common base
 or not
\end_layout

\begin_layout Itemize
Evaluation of reads from 
\family typewriter
malloc
\family default
'd memory, or memory from another user-nominated allocator obeying the same
 contract.
\end_layout

\begin_layout Itemize
Evaluation of reads whose results depend on target-specific struct layout,
 array alignment and similar.
 This is possible because LLVM IR explicitly encodes the target-specific
 layout and alignment rules which will be used when lowering to assembly.
\end_layout

\begin_layout Itemize
Evaluation of reads that are defined by writes of a different type (e.g.
 2 
\family typewriter
int16
\family default
 stores that define an 
\family typewriter
int32
\family default
 load).
\end_layout

\begin_layout Itemize
Exceptions as implemented by the 
\family typewriter
llvm-g++
\family default
 and 
\family typewriter
clang
\family default
 compilers.
\end_layout

\begin_layout Standard
Our coverage is not 100% however.
 We still lack support for programs that use pointer arithmetic not covered
 above: we do not support arbitrary inspection of the high bits of a pointer,
 as a hash table might use to determine the pointer's hash bucket, or comparison
 of pointers without a common base as might be used to sort an array of
 pointers.
 Our support for data reinterpretation is limited to non-pointer types,
 again because we don't know anything about their numerical values at specialisa
tion time, but we could improve support here by including 
\family typewriter
malloc
\family default
 in the domain of specialisation and modelling the behaviour of memory allocatio
n system calls.
\end_layout

\begin_layout Standard
We also currently do not support inline assembly, although the impact of
 this limitation is minimised because we support 
\family typewriter
memset
\family default
, 
\family typewriter
memcpy
\family default
 and 
\family typewriter
memmove
\family default
 as intrinsics.
 This could be improved by using an LLVM disassembler, which currently exist
 for x86 and ARM architectures.
\end_layout

\begin_layout Subsection
Post-processing
\end_layout

\begin_layout Standard
After the main PE phase has completed, LLPE runs a series of cleanup passes
 over the program to be emitted.
 These are conceptually seperate from PE, in that they do not use the detailed
 analysis that drives PE but rather can be run entirely seperately, but
 they are important to fully realising the benefits of PE and are included
 in our evaluation results below.
\end_layout

\begin_layout Standard
Post-PE cleanup passes are used to eliminate dead stores (i.e.
 store instructions which cannot possibly be read), dead allocation sites
 including 
\family typewriter
malloc
\family default
 / 
\family typewriter
realloc
\family default
 / 
\family typewriter
free
\family default
 graphs that no longer have 
\family typewriter
load
\family default
 or 
\family typewriter
store
\family default
 users, dead global variables, and 
\family typewriter
open
\family default
 / 
\family typewriter
close
\family default
 calls that are not otherwise used.
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialised (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction (%)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300456
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
240968
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
68704
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24472
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64.4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
229504
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
214688
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16528
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13568
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
date
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialised (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction (%)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
284024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
255360
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
59520
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38184
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
220536
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
214320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14216
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13392
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
printf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialised (b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction (%)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256168
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
240640
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35776
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27848
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
218776
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
211090
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13944
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13328
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
md5sum
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We evaluated our prototype specialiser using 3 sample programs from the
 GNU coreutils: 
\family typewriter
date
\family default
, 
\family typewriter
printf
\family default
 and 
\family typewriter
md5sum
\family default
.
 All were statically linked against uclibc.
\end_layout

\begin_layout Standard

\family typewriter
date
\family default
 was specialised with respect to its environment, which sets the LC family
 of locale variables to en_GB.UTF-8 and its command line, which is empty.
 It is also specialised with respect to the contents of /etc/timezone and
 /etc/TZ, which give the local system's preferred timezone.
 This yields a date program which is specialised to display the time (discarding
 the ability to set the time) in a particular timezone and with the program's
 default format.
 We discuss the program's structure and the code eliminated in detail below.
\end_layout

\begin_layout Standard

\family typewriter
printf
\family default
 was specialised with respect to its environment, which sets the LC variables
 as for 
\family typewriter
date
\family default
, and partially with respect to its command line: we specify that its first
 argument is 
\family typewriter

\begin_inset Quotes eld
\end_inset

%d %s
\begin_inset Quotes erd
\end_inset


\family default
 and that the total number of arguments is (appropriately) 3, but leave
 the other two arguments unspecified.
 This produces a printf program which renders exactly one number and then
 one string, allowing us to discard formatting code for other types.
 This models the kind of specialisation we could make if we saw a script
 which contained the text 
\family typewriter
'/usr/bin/printf 
\begin_inset Quotes eld
\end_inset

%d %s
\begin_inset Quotes erd
\end_inset

 $1 $2'
\family default
.
 The code size reduction for this program results mainly from eliminating
 several functions in the printf family: in particular we are able to discard
 large sections of code dedicated to dealing with wide character strings
 as we are able to establish that with this format string those routines
 will never be called.
\end_layout

\begin_layout Standard
Finally, 
\family typewriter
md5sum
\family default
 was specialised with respect to its command-line and the contents of the
 file it digests.
 Perhaps surprisingly this does not lead to much of a reduction in code
 size: this is because the implementation of the md5 algorithm is quite
 small.
 The residual code is mostly part of the 
\family typewriter
stdio
\family default
 library, used to print the now-known result to stdout.
 We are also forced to retain error-reporting code paths that are exercised
 when printing to stdout fails.
\end_layout

\begin_layout Standard
Tables 1, 2 and 3 summarise the code size reductions achieved, giving the
 byte sizes for each program as stored on disk, as well as the ELF file's
 given size for the text, rodata and bss segments, representing the elimination
 of code, constant data and global variables respectively.
 No other segments contributed more than 1% of any object's size.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
To give an example of the kind of optimisation opportunities available through
 specialisation, we describe an example in detail: the date program.
\end_layout

\begin_layout Standard
The program is ostensibly simple: all it must do is print and set the system
 time.
 However, despite the time being necessarily a dynamic parameter, it is
 possible to specialise the date program to a significant degree, improving
 both its running time and its code and date size.
\end_layout

\begin_layout Standard
We specialise the date program with respect to its environment, which defines
 the locale rules for printing numbers, dates and times using the LC_ family
 of variables, the command-line, which we define to be empty (yielding a
 program that just prints the date), and the files /etc/TZ and /etc/timezone,
 which specify the local timezone.
\end_layout

\begin_layout Standard
The program's structure is more complicated than it would intuitively seem,
 because of support for several different operations (setting the time,
 reading a file timestamp, reading a file that itself lists files), and
 because of support for many different locales with different conventions
 for time representation.
\end_layout

\begin_layout Standard
Its implementation is also inefficient due to expediency on the part of
 the developers: they wished to support specification of the date format
 string using a language which is similar to, but slightly extended from,
 that accepted by strftime.
 In order to avoid rewriting strftime in its entirety, they filter its output,
 repeatedly calling it with short (single-replacement) format strings.
 However, each call to strftime results in two calls to tzset, both of which
 read anew the local machine's timezone information, stored in /etc/TZ or
 /etc/timezone.
\end_layout

\begin_layout Standard
The result is that the apparently simple task of printing the date string
 is achieved by two large parsers (each of strftime and the wrapper function
 fills roughly 8K in the binary image).
 Along with fscanf and strptime, which are only used in the time-setting
 path, inlining these functions reduces the program's code size by around
 20%, and statically evaluating the repeated calls to tzset, including their
 filesystem operations, reduces running time by 10% with a hot page cache
 (i.e., with the /etc/timezone file already in memory).
\end_layout

\begin_layout Standard
The largest gain, however, is as-yet unrealised: we need to eliminate the
 locale database.
 This is a large (200k) structure stored as inline read-only data which
 provides formatting information for different locales; however, it is only
 needed when calling date with certain format strings that print a locale-specif
ic representation.
 Its elimination would reduce the binary size by 80%.
 However in order to achieve this benefit we need to extend our analysis
 somewhat: see Future Work below for details.
\end_layout

\begin_layout Standard
The date program also presents some challenges to specialisation, requiring
 annotation in some places.
 The loops of both strftime and its wrapper contain a number of error exit
 paths, making it difficult to establish whether the loop should be peeled
 another iteration or whether this would simply inflate the output code
 size with specialised code that will usually be bypassed.
 We annotate these edges as unlikely, meaning the specialiser assumes that
 the loop will usually terminate for a different reason and goes on to explore
 further iterations (in fact the usual termination condition is reaching
 the end of the format string).
 We also annotate functions which the specialiser does not explore because
 they are not certain to be executed.
 Of the N annotations for the date program, M are of this kind and we expect
 these to become unnecessary as we improve the specialiser's exploration
 strategy.
\end_layout

\begin_layout Standard
A second problem is that the date program features a lot of difficult-to-analyse
 pointer arithmetic, mostly stemming from the stdio library.
 Rather than store indices and use these to index into arrays, the library
 stores pointers which it increments and decrements as the user calls stdio
 functions.
 These manifest in LLVM as getelementptr instructions, deriving one pointer
 from another, with a non-constant base address.
 These cases can be dealt with fully automatically, however: the specialiser
 is able to establish that the loops within fwrite and related functions
 always deal with pointers ultimately derived from a particular base object
 (a statically allocated buffer), and consequently these stdio functions
 do not present an insurmountable barrier to alias analysis and therefore
 further exploration of the program.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
We will continue to develop LLPE, improving its coverage and efficiency;
 in particular we plan to use the online-offline mixed 
\begin_inset CommandInset citation
LatexCommand cite
key "sumii1999efficientonlinepe"

\end_inset

 PE approach to dramatically speed up PE.
 At a larger scale we intend to complete the implementation of our current
 LLPE design by implementing guards, and then extend it in two key ways:
 first, to integrate the system into an end-to-end profiling and specialisation
 system that can identify and exploit system-wide specialisation opportunities
 with zero user intervention, and second, to support PE of systems using
 a broader subset of the POSIX API.
\end_layout

\begin_layout Subsection
Implementing Guards
\end_layout

\begin_layout Standard
We currently support specialising programs with respect to 3 different kinds
 of parameter: command-line arguments, environment variables and the contents
 of files.
 Guards for the first two are trivial, but guards for files are a little
 more challenging.
 
\end_layout

\begin_layout Standard
In order to ensure that the view of a file is consistent between specialisation
 time and runtime, we plan to implement the guard by statically rewriting
 certain 
\family typewriter
open
\family default
 system calls in the specialised program.
 Specifically, when LLPE processes a program involving filesystem operations,
 it can execute some 
\family typewriter
read
\family default
 calls at specialisation time.
 If it does, the 
\family typewriter
read
\family default
 calls are not present in the specialised program, and instead the 
\family typewriter
open
\family default
 call is immediately followed by an llseek call to set the file position
 appropriately.
 In this situation we must ensure that the file we are about to seek into
 matches the data we received at specialisation time.
 We plan to allow the user to choose between two possible schemes at this
 point: we could either check that the file's modifcation time matches our
 expectations, or include a checksum of the file contents read at specialisation
 time to be verified at runtime.
 We expect a weak checksum to be cheaper than the parsing work that has
 been executed at specialisation time; we don't plan to use a stronger hash
 algorithm such as SHA-1 because it would likely reverse the benefits of
 partial evaluation, and guards are designed to avoid accidental misuse
 of a specialised program, not to protect against malicious input.
\end_layout

\begin_layout Standard
It is still possible for the program to see an inconsistent view of the
 file if it opens it more than once, but we would argue that this is a bug
 in the input program, since the file could be replaced entirely between
 two opens even without specialisation being involved.
 We could nontheless allow the user to specify an 
\begin_inset Quotes eld
\end_inset

extra paranoid
\begin_inset Quotes erd
\end_inset

 mode in which we checksum any file that has been read at specialisation
 time whenever it is opened; however the costs of checking every 
\family typewriter
open
\family default
 call against the list of files read at specialisation time and checksumming
 are likely to outweigh the benefits of PE in this case.
\end_layout

\begin_layout Subsection
Broader POSIX Coverage
\end_layout

\begin_layout Standard
Whilst we currently support filesystem operations, we plan to significantly
 extend our ability to specialise programs based on assumptions about their
 interactions with external programs and systems.
 We will treat network operations similarly to disk operations, allowing
 us to specialise e.g.
 a web server to assume that all incoming connections begin a certain way
 (perhaps useful if the server is a backend to 
\family typewriter
mod_proxy
\family default
 and so we know it will always be addressed a certain way).
\end_layout

\begin_layout Standard
More challenging is the 
\family typewriter
clone
\family default
 system call, which can introduce further threads of control into the same
 address space.
 PE of concurrent programming languages has been investigated in toy languages
 similar to CSP 
\begin_inset CommandInset citation
LatexCommand cite
key "marinescu1997conc"

\end_inset

, and we intend to investigate how far its lessons can be extended to deal
 with programs using 
\family typewriter
futex
\family default
 to communicate, e.g.
 programs using glibc's implementation of POSIX threads.
\end_layout

\begin_layout Subsection
Systemwide Specialisation
\end_layout

\begin_layout Standard
We intend to use LLPE to create a whole-system specialiser.
 Working in an all-LLVM ecosystem, we will use lightweight profiling to
 map all processes created on a system and use this information to inform
 profitable specialisation: for example, we might notice that a program
 is frequently used with the same arguments, or that it spends a lot of
 time reading a particular file which rarely changes.
 We could then use system idle time to construct a specialised version of
 the program.
\end_layout

\begin_layout Standard
Specialised programs will be transparently switched in for the 
\begin_inset Quotes eld
\end_inset

real thing
\begin_inset Quotes erd
\end_inset

 using wrapper scripts that check when a specialised version of a program
 is applicable.
 The original, unspecialised program will be used otherwise, and the specialised
 version discarded if its assumed conditions are not true and not likely
 to be true in the future, perhaps leading to respecialisation if a new
 stable state develops.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Partial evaluators have been developed for both functional languages such
 as Lisp 
\begin_inset CommandInset citation
LatexCommand cite
key "beckman1976lisp"

\end_inset

 and Scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "berlin1990scheme1,weise1991fusescheme"

\end_inset

, and for imperative languages including Fortran 
\begin_inset CommandInset citation
LatexCommand cite
key "baier1994fortran"

\end_inset

, C 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix,consel2004tour"

\end_inset

 and Java 
\begin_inset CommandInset citation
LatexCommand cite
key "affeldt2002javaruntime,schultz2003jspec,shali2011hybridpe"

\end_inset

.
 For a more complete roundup of partial evaluators see reviews 
\begin_inset CommandInset citation
LatexCommand cite
key "beckmann1996partial,jones1996introduction"

\end_inset

.
\end_layout

\begin_layout Subsection
C-Mix
\end_layout

\begin_layout Standard
The partial evaluators C-mix 
\begin_inset CommandInset citation
LatexCommand cite
key "makholm1999cmix2,andersen1994cmix"

\end_inset

 and Tempo 
\begin_inset CommandInset citation
LatexCommand cite
key "consel2004tour"

\end_inset

 have made the most progress in specialising complete C programs.
 C-mix targets the full C language; however, it conservatively residualises
 code featuring difficult-to-analyse constructions such as pointer arithmetic
 and type puns achieved by pointer casting or union types.
 It is an ahead-of-time, offline PE (see section 2), going so far as to
 emit its BTA results realised as an executable program, termed a generating
 extension, which takes concrete specialisation-time arguments and emits
 fully specialised programs.
 If multiple specialisations of a program are desired, specialising with
 respect to the same arguments but differing in their concrete values, this
 may be much faster than online PE such as ours which would require a full
 specialisation run for each different set of argument values.
\end_layout

\begin_layout Standard
As an offline PE with a monovariant BTA, it is conservative when selecting
 which statements and expressions can be evaluated at specialisation time:
 whilst it does specialise functions per static callsite, at an intraprocedural
 level it will residualise all uses of variables which are at any point
 assigned dynamic values or under dynamic control.
 Other limitations include a lack of support for malloc and other functions
 manipulating heap memory, the possibility of specialiser non-termination
 on source programs which themselves always terminate, and the need to annotate
 external functions' side-effects and global variables' visibility to other
 translation units.
 The latter limitation arises because most C programs are compiled by seperate
 compilation of both translation units within a program and pre-compiled
 libraries.
\end_layout

\begin_layout Standard
C-mix has been evaluated both by its creators, achieving up to 50% reduction
 in runtime at the cost of sometimes-significant code size increase specialising
 a 10KLOC raytracer with respect to its scene description, and by others
 
\begin_inset CommandInset citation
LatexCommand cite
key "jung2005cmix2user"

\end_inset

, achieving up to 60% code size reduction evaluating an operating system
 kernel with respect to its configuration.
\end_layout

\begin_layout Subsection
Tempo
\end_layout

\begin_layout Standard
Tempo is another offline PE, but unlike C-Mix is capable of operating both
 ahead of time and at runtime.
 Its BTA is more precise than that of C-Mix 
\begin_inset CommandInset citation
LatexCommand cite
key "hornof1997tempobta"

\end_inset

, permitting it to execute computations at specialisation time even when
 variables involved are sometimes under dynamic control, but it is nontheless
 a monovariant BTA at the intraprocedural level, meaning it conflates iterations
 of loops, and despite polyvariance at the interprocedural level it conflates
 recursive procedure calls in order to guarantee specialiser termination.
 
\end_layout

\begin_layout Standard
Unlike C-Mix, Tempo was explicitly designed for systems applications, and
 has been evaluated in many real-world scenarios, including specialising
 RPC serialisation routines with respect to the data type that will be serialise
d 
\begin_inset CommandInset citation
LatexCommand cite
key "mcnamee2001temporpcbpf"

\end_inset

, a Berkeley Packet Filter interpreter with respect to its program, and
 a Java bytecode interpreter with respect to its input program.
 
\end_layout

\begin_layout Standard
Whilst these applications are important successes, and exhibit Tempo's maturity
 as a practical tool, it shares C-Mix's limitations when dealing with seperate
 compilation and when dealing with heap-allocated memory: Tempo's alias
 analysis conflates all heap allocated memory 
\begin_inset CommandInset citation
LatexCommand cite
key "emami1994aa"

\end_inset

, meaning specialisation-time execution of loads and stores in that memory
 is effectively forbidden.
\end_layout

\begin_layout Subsection
Online PE
\end_layout

\begin_layout Standard
As an online PE, our specialiser's primary goal is maximum specialisation
 rather than to optimise efficiency of the specialisation process, in contrast
 to C-Mix and Tempo, both of which used an offline strategy.
 Online PEs have been developed for a functional subset of Scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "berlin1990scheme1,weise1991fusescheme"

\end_inset

, and for Prolog 
\begin_inset CommandInset citation
LatexCommand cite
key "sahlin1990mixtus"

\end_inset

.
 These systems boast large (greater than 10x) speedups applied to numerical
 kernels and toy programs respectively, but have not been evaluated on realistic
 whole programs.
 
\end_layout

\begin_layout Standard
Later online PEs targeted imperative languages including a subset Pascal
 
\begin_inset CommandInset citation
LatexCommand cite
key "meyer1999upascal"

\end_inset

 and full Java 
\begin_inset CommandInset citation
LatexCommand cite
key "shali2011hybridpe"

\end_inset

.
 The latter, named Civet, uses a hybrid approach in which the programmer
 manually annotates subsets of the program to be specialised and offline
 BTA is conducted to check the consistency of their annotations, before
 a full online PE is used at specialisation time.
\end_layout

\begin_layout Subsection
Runtime PE
\end_layout

\begin_layout Standard
PEs operating at runtime have the potential to exploit specialisation opportunit
ies not available to ahead-of-time PE, because all concrete parameters are
 available to them, enabling the PE to dynamically analyse and optimise
 for emergent situations which the programmer or user did not necessarily
 anticipate.
 On the other hand, runtime PEs are much more resource-constrained than
 ahead-of-time PEs because they offset any speedup to their target program
 against the cost of specialisation.
 
\end_layout

\begin_layout Standard
Runtime PEs often include an ahead-of-time BTA (
\begin_inset CommandInset citation
LatexCommand cite
key "consel1996temporuntime,khan2008runtimetempl"

\end_inset

) to reduce this cost as much as possible, reducing their runtime task to
 simply filling in pre-prepared executable templates.
 The Synthesis kernel 
\begin_inset CommandInset citation
LatexCommand cite
key "pu1988synthesis"

\end_inset

 achieved significant runtime reduction using hand-written templates for
 filesystem-operation system calls.
 Tempo (see above) can use the same BTA stage that drives its ahead-of-time
 specialiser to build templates for runtime specialisation, and was later
 combined with the Synthesis kernel to automatically generate and instantiate
 the templates which were previously produced by hand 
\begin_inset CommandInset citation
LatexCommand cite
key "pu1995synthetix"

\end_inset

.
\end_layout

\begin_layout Standard
Whilst the PEs above restrict their runtime phase to instantiating templates
 in the name of efficiency, some runtime specialisers such as DyC 
\begin_inset CommandInset citation
LatexCommand cite
key "grant2000dyc"

\end_inset

 and Dynamo 
\begin_inset CommandInset citation
LatexCommand cite
key "bala2000dynamo"

\end_inset

 also perform runtime peephole optimisation on their generated code.
 A runtime PE for Java 
\begin_inset CommandInset citation
LatexCommand cite
key "affeldt2002javaruntime"

\end_inset

 works at the Java bytecode level and so defers optimisation to the JIT
 compiler.
\end_layout

\begin_layout Subsection
Large Scale Specialisation
\end_layout

\begin_layout Standard
Several prior projects have attacked the problem of specialising entire
 pieces of software, or even entire systems.
 Both Charon 
\begin_inset CommandInset citation
LatexCommand cite
key "perianayagam2006charon"

\end_inset

 and a Ghent system based on Diablo 
\begin_inset CommandInset citation
LatexCommand cite
key "chanet2005system"

\end_inset

 aimed to specialise the Linux kernel with respect to a corpus of userspace
 programs that will be run, targeting embedded systems where the set of
 programs that can be run is tightly controlled.
 By working at the binary level they were forced to spend a great deal of
 effort disassembling and inferring high-level semantic information, and
 needed to act conservatively where that analysis was insufficient, but
 nontheless were able to eliminate unused system calls and consequent dead
 code.
 They also introduced specialised system calls when their userspace programs
 could be shown to frequently invoke them with particular parameters.
 Their specialisation of these calls was limited, however, by the fidelity
 of their disassembly and subsequent analysis.
\end_layout

\begin_layout Subsection
Whole Program Analysis and LLVM
\end_layout

\begin_layout Standard
LLVM is perfect for whole program analyses like ours because it provides
 tools to link translation units and libraries whilst retaining the high-level
 semantic information necessary for aggressive analysis and transformation.
 KLEE 
\begin_inset CommandInset citation
LatexCommand cite
key "cadar2008klee"

\end_inset

 is a program analysis tool which searches for program inputs which can
 cause crashes and other bugs by propagating value constraints through LLVM
 programs, similar to how our tool propagates possible value sets.
 Another attribute our work shares with KLEE is that we have both implemented
 or mocked up a subset of the POSIX API in order to allow specialisation
 and analysis, respectively, of programs including system calls.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In this paper we have described a partial evaluator that targets whole LLVM
 programs running in a POSIX environment, called LLPE, and exhibited a prototype
 that significantly reduces runtime and code size for mid-sized example
 programs.
 We will continue to develop LLPE to address larger programs and integrate
 it to specialise across a whole system, aiming to produce a practical specialis
er for general purpose software which requires little or no user interaction.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "pldi2013"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
