#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[compact]{titlesec}
\date{}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding global
\font_roman times
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\columnsep 0.25in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
\size large
LLPE: A Practical Specializer for LLVM Programs
\end_layout

\begin_layout Author
Paper #198, 15 pages
\end_layout

\begin_layout Subsection*
Abstract
\end_layout

\begin_layout Standard
We present the design and prototype implementation of LLPE, a specializer
 for real-world large programs written in languages which can be compiled
 to LLVM bitcode, such as C and C++.
 LLPE specializes whole programs with respect to a user-supplied command-line,
 environment, and/or filesystem image and produces a specialized program
 which is smaller and faster to execute.
 It improves LLVM bitcode using partial evaluation, a program transformation
 that combines the techniques of constant propagation, dead code elimination,
 loop peeling and procedure inlining.
 LLPE supports almost all LLVM programs, including support for arbitrary
 pointer indirection, data reinterpretation and restricted pointer arithmetic.
\end_layout

\begin_layout Standard
We evaluate LLPE on programs from the GNU Coreutils suite compiled against
 
\family typewriter
uclibc
\family default
, an XML parser based on 
\family typewriter
libxml2
\family default
/
\family typewriter
libxslt
\family default
, and the tiny webserver Mongoose.
 We achieve code size reductions up to 85% and runtime reductions up to
 54%.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The software we use on a day-to-day basis is often much more general than
 it needs to be for the task for which it is employed.
 Specialized software can consume less memory, energy and execution time
 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

, but specialization of large programs for a specific task is seldom seen
 in practice.
 This is because hand-specializing programs is time-consuming and error-prone,
 with the development and testing time likely to outweigh the resources
 saved running the specialized software.
 By automating the specialization process, specialization can be turned
 from a task of weeks to one of hours, and therefore made practically applicable
 to everyday real-world programs.
\end_layout

\begin_layout Standard
Partial evaluation is a program transformation which can perform automated
 specialization.
 In this paper, we present the design of a partial evaluator (PE) for real-world
-scale LLVM 
\begin_inset CommandInset citation
LatexCommand cite
key "lattner2004llvm"

\end_inset

 programs, called LLPE
\begin_inset Foot
status open

\begin_layout Plain Layout
Pronounced 
\begin_inset Quotes eld
\end_inset

ell-pee
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

, which specializes whole programs with respect to command-line parameters,
 environment variables and/or a filesystem image.
 We aim for high accuracy and minimum user input into the specialization
 process.
\end_layout

\begin_layout Standard
PEs must trade off between the cost of specialization and how closely they
 can approximate theoretically optimal specialization, called their accuracy.
 We target use cases where specialization can be performed ahead-of-time,
 and a specialized program is expected to be used many times before it is
 re-specialized, and so performance of the specialized program is much more
 important than that of the specializer.
\end_layout

\begin_layout Standard
Because we aim to automate the PE process entirely, we aggressively explore
 all possible paths of execution in the target program, restricted to ensure
 
\emph on
soundness
\emph default
 (the emitted program must be observationally equivalent to the input program,
 modulo specialized arguments) and 
\emph on
termination
\emph default
 of the specializer.
 However because proving termination is difficult, we also degrade gracefully
 to support simple, easy-to-use annotations that provide hints when LLPE
 would otherwise underspecialize the input program.
\end_layout

\begin_layout Standard
By targeting LLVM intermediate representation (IR), LLPE can exploit many
 useful properties of the LLVM ecosystem.
 We can easily specialize whole programs consisting of more than one translation
 unit, including library code, without requiring user description of externals,
 since LLVM tools make it easy to produce final linked IR images which retain
 sufficient high-level semantic information for program transformations
 like PE.
 Due to the widespread availability of compilers targeting LLVM, we can
 also target programs written in many source languages, including C, Objective-C
, C++ and Haskell amongst others, as well as multi-lingual projects (e.g.
 a C++ program linking a pure C library).
\end_layout

\begin_layout Standard
We have implemented a prototype realizing a large portion of our design,
 and describe our implementation, along with the challenges we anticipate
 completing our system.
 We evaluated LLPE on programs from the GNU Coreutils suite compiled against
 
\family typewriter
uclibc
\family default
, an XML parser based on 
\family typewriter
libxml2
\family default
/
\family typewriter
libxslt
\family default
, and the tiny webserver 
\family typewriter
mongoose
\family default
.
 We achieve code size reductions up to 85% and runtime reductions up to
 54%.
\end_layout

\begin_layout Subsection
Contributions
\end_layout

\begin_layout Standard
The contributions of this paper relative to prior work are as follows:
\end_layout

\begin_layout Itemize
A design for a PE system targeting LLVM IR, which takes existing techniques
 such as symbolic execution over a domain of sets of concrete values, and
 a highly aggressive path-sensitive alias analysis, and applies them to
 the problem of partial evaluation of low-level imperative languages for
 the first time, surpassing previous leaders in the field such as C-Mix
 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

 and Tempo 
\begin_inset CommandInset citation
LatexCommand cite
key "consel1996tempobasic"

\end_inset

 in terms of accuracy (as defined in ยง3).
 A particularly important improvement over those previous PEs is that we
 interleave alias analysis with constant propagation and dead code elimination,
 taking the results of each into account when calculating the other.
\end_layout

\begin_layout Itemize
We evaluate the cost and benefit of specialization applied to whole, real-world
 programs, unlike previous work which always manually identified a sub-module
 or function for specialization.
\end_layout

\begin_layout Itemize
Support for specialization with respect to state exposed via system calls
 and the elimination of runtime I/O operations and,
\end_layout

\begin_layout Itemize
A user-customizable algorithm for assessing the cost of PE after analysis
 but before writing a specialized program, allowing the user to trade output
 program code size against performance.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
It is common for very general software to be used where a more specialized
 program would have done the job.
 Fully featured web servers are used to serve static content; regular expression
 parsers are used when their search expression is so simple that it boils
 down to 
\family typewriter
strstr
\family default
; fully-featured databases with support for ACID transactions and clustering
 are used in applications that in fact only call for a single-user hash
 table.
 This usually happens out of expediency: the tool exists, is familiar to
 the user, definitely does the required job (despite doing many dozens of
 other things as well), and there is little motivation to invent a better
 solution when resources (CPU cycles, memory) are plentiful.
\end_layout

\begin_layout Standard
We may want to employ such general-purpose, inefficient prototypes in a
 setting where resource consumption 
\emph on
is
\emph default
 important.
 This might be because the prototype will be run in a cloud computing environmen
t which is billed per CPU cycle or byte of memory consumed, or because the
 ultimate target is an embedded environment with physical resource restrictions,
 or because a network service became unexpectedly popular to the point that
 it taxes its host hardware.
 In such cases we need to take action to meet our resource budget.
 We could customize the software by hand, but the development and debugging
 costs of such modifications may be excessive.
 We could sacrifice functionality and use a system designed explicitly for
 restricted environments (such as trading in GNU Coreutils for 
\family typewriter
busybox
\family default
), but such an alternative might not be readily available, and the replacement
 might have subtly different behavior and bugs to the original, or may offer
 a restricted feature subset that is not convenient to our needs.
\end_layout

\begin_layout Standard
Using partial evaluation we can have our cake and eat it too: the existing,
 large program can be specialized with respect to invariants that we know
 about its operating context to produce a smaller, faster program that behaves
 identically to the original so long as the invariants are maintained and
 the specializer is correct.
\end_layout

\begin_layout Subsection
Partial Evaluation
\end_layout

\begin_layout Standard
Partial evaluation (PE), also known as program specialization or staged
 compilation, describes the simplification of a program assuming some specializa
tion conditions, producing a residual program which is observationally equivalen
t to the original so long as those specialization conditions are obeyed.
\end_layout

\begin_layout Standard
As a trivial example, one could specialize the 
\family typewriter
printf
\family default
 function to assume that its first argument will be 
\family typewriter
"%d"
\family default
.
 Under this assumption, 
\family typewriter
printf
\family default
 reduces to a function that prints a single integer as a decimal.
 The resulting code will be smaller, as 
\family typewriter
printf
\family default
's other output routines can be discarded, and faster to execute, because
 instructions that examine the format string can be evaluated ahead of time.
 The specialized function might be small enough to consider inlining, which
 will eliminate the cost of a call/return sequence entirely.
 The specialized function is equivalent to the original so long as the specializ
ation condition (that the first parameter is 
\family typewriter
"%d"
\family default
) is true.
 If the specialization condition is false undefined behavior will result
 from using the specialized version, and so PE systems must either prove
 at specialization time or check at runtime that their use is appropriate.
\end_layout

\begin_layout Standard
PE of entire programs extends this idea by specializing with respect to
 the arguments supplied to the program's entry point (i.e.
 its command-line arguments or environment), as well as implicit parameters
 examined using system calls, such as the contents of the filesystem.
 Specialization with respect to external state requires that we either depend
 on the user to obey those conditions (with undefined behavior if they don't),
 or that the specializer emits code to check those conditions (called guards).
 For example, if the 
\family typewriter
printf
\family default
 example above were to take its format string from a command-line argument,
 we would either note that calling with a different format string will lead
 to undefined behavior or emit a guard which checks that the format string
 is as expected and either exits or branches to unspecialized code otherwise.
 Guards can also select at runtime between several specialized versions
 of a program or subprogram, each of which assumes different specialization
 conditions.
\end_layout

\begin_layout Standard
A particularly important specialization opportunity for whole-program PE
 is to elide I/O operations where possible.
 This can improve performance significantly because whilst CPU performance
 has improved rapidly, I/O device latency improves much more slowly, and
 so programs commonly spend a large proportion of their runtime waiting
 on I/O devices.
\end_layout

\begin_layout Standard
PE can take place ahead of time (sometimes called static PE), in which specializ
ation conditions are specified in advance and a specialized program is produced
 but the specializer plays no further role at runtime, or can take place
 at runtime (called dynamic PE), in which the specializer is present in
 the executable and generates code at runtime, akin to a just-in-time compiler.
 PE systems can also be divided into online and offline PEs; we describe
 the distinction in a little more detail in ยง7, but for now it suffices
 to note that online PEs are generally more accurate but less efficient
 than offline PEs 
\begin_inset CommandInset citation
LatexCommand cite
key "christensen2004offvsonline"

\end_inset

.
 
\end_layout

\begin_layout Standard
We present a design for an ahead-of-time, online PE, because we aim to produce
 highly specialized programs which we expect to re-specialize infrequently,
 meaning we value the efficiency of the specialized program more than that
 of the specializer itself.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
To illustrate the kind of optimization opportunities available through PE,
 we will give a detailed example: the 
\family typewriter
date
\family default
 program.
\end_layout

\begin_layout Standard
The program is ostensibly simple: all it must do is print and set the system
 time.
 However, despite the time being necessarily a dynamic parameter, it is
 possible to specialize the date program to a significant degree, improving
 both its running time and its code and data size.
 We can specialize the program with respect to the user's locale, conveyed
 as environment variables and responsible for controlling date formatting
 style, and the system timezone data, typically stored on disk.
\end_layout

\begin_layout Standard
The program's structure is more complicated than it would intuitively seem,
 because of support for several different operations (setting the time,
 reading a file timestamp, reading a file that itself lists files), and
 because of support for many different locales with different conventions
 for time representation.
 Its implementation is also inefficient due to expediency on the part of
 the developers: they wished to support specification of the date format
 string using a language which is similar to, but slightly extended from,
 that accepted by 
\family typewriter
strftime
\family default
.
 In order to avoid rewriting 
\family typewriter
strftime
\family default
 in its entirety, they filter its output, repeatedly calling it with short
 (single-replacement) format strings.
\end_layout

\begin_layout Standard
When we specialize the 
\family typewriter
date
\family default
 program with respect to our locale, this tells us the format string that
 will be passed into their augmented 
\family typewriter
strftime
\family default
, and then, by evaluating that parser, to the sub-calls to the underlying
 
\family typewriter
strftime
\family default
.
 Each 
\family typewriter
strftime
\family default
 call can then be reduced to the formatter for a single value type, such
 as a month or year value, and the construction and parsing of format strings
 eliminated.
 The output program will be faster to execute.
 It is also likely to be smaller, because this is the only situation in
 which 
\family typewriter
date
\family default
 calls 
\family typewriter
strftime
\family default
, and so we can delete the unspecialized version of the function.
 specializing 
\family typewriter
date
\family default
 in this way is not necessarily useful in itself, but illustrates the kind
 of improvements that are possible even for programs that are primarily
 wrappers around system calls.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
We present the design of LLPE, an ahead-of-time online PE for LLVM bitcode
 with optional guards.
 It combines well-known analyses into a novel specialization strategy to
 produce a specializer capable of processing real-world programs, surpassing
 previous work in the scale of its input programs, its coverage of the source
 language and the accuracy (as defined below) of its output.
\end_layout

\begin_layout Standard
Our high-level design goals are as follows:
\end_layout

\begin_layout Standard

\series bold
\emph on
Soundness
\series default
\emph default
.
 We only specialize programs using facts about the program we can determine
 for certain given the specialization conditions, and only use information
 about the target machine when one is explicitly given.
 Naturally bugs in the specializer can undermine soundness, but we seek
 to minimize the risk by using well-exercised kernels from core LLVM transformat
ion passes where possible.
\end_layout

\begin_layout Standard

\series bold
\emph on
Accuracy
\series default
\emph default
.
 Instructions that cannot be evaluated during specialization must be 
\emph on
residualized
\emph default
, that is, emitted in the specialized program.
 We aim to maximize LLPE's 
\emph on
accuracy
\emph default
, minimising the number of residual instructions for a given input, at the
 expense of the efficiency of LLPE itself, because we target situations
 where specialization can be run ahead-of-time and the space and time savings
 for the target program outweigh the costs of specialization.
 We especially target high accuracy in the presence of system calls, to
 permit useful specialization of I/O-intensive programs.
\end_layout

\begin_layout Standard

\series bold
\emph on
Scalability
\series default
\emph default
.
 In order to effectively specialize large programs, we must derive facts
 about the entire target program, such as bounding the memory side-effects
 of large call-graphs.
 To scale our analyses to large programs we use several levels of analysis,
 characterising functions' and loops' behavior first in a context-insensitive
 manner, then again considering their parameters, and then finally, if necessary
, considering their dynamic execution context.
 This enables us to abbreviate program analysis by using simpler levels
 of analysis when they suffice.
\end_layout

\begin_layout Standard

\series bold
\emph on
Usability
\series default
\emph default
.
 We aim to heuristically explore the target program in full without user
 input.
 However if LLPE cannot fully exploit the available information we support
 easy-to-understand and use annotations, allowing the user to provide extra
 guidance without threatening correctness.
\end_layout

\begin_layout Standard

\series bold
\emph on
Practicality
\series default
\emph default
.
 We target LLVM bitcode in order to support programs written in many low-level
 programming languages, including C and C++, whilst providing a source language
 whose semantics are well specified and which is small enough that broad
 coverage is practical.
\end_layout

\begin_layout Standard
We will describe the detailed design of LLPE starting with a basic design
 which is then incrementally elaborated upon to improve accuracy and efficiency.
 We use a series of illustrative example programs which are expressed in
 C-like SSA-form pseudocode, with an explicit 
\family typewriter
phi
\family default
 operation that merges values at control flow merge points.
\end_layout

\begin_layout Subsection
Basic Design
\end_layout

\begin_layout Standard
LLPE analyses its input program to try to reduce it to a simpler, specialized
 program.
 Like most online PEs, it is structured similarly to an interpreter.
 Starting at the program entry point, it evaluates each LLVM instruction,
 calculating its result if its arguments are known or marking it to be residuali
zed otherwise.
 Instructions are in effect symbolically executed over a domain consisting
 of constants, symbolic pointers (allocation and offset pairs), symbolic
 file descriptors used to model system call interactions, and a special
 
\begin_inset Quotes eld
\end_inset

residualize
\begin_inset Quotes erd
\end_inset

 value.
 For now, consider instructions to only have a single such value, and pointers
 to have exact symbolic addresses: we will lift both these restrictions
 later.
\end_layout

\begin_layout Standard
Like an ordinary interpreter, when LLPE encounters a call instruction it
 evaluates the called function in context; similarly it follows the natural
 structure of known branches (including loops) at specialization time, analysing
 loop bodies individually for each iteration.
 Instructions are thus evaluated as accurately as possible taking into account
 all available context.
 When we encounter a conditional branch which cannot be decided at specializatio
n time (a 
\emph on
dynamic branch
\emph default
), both successor paths need to be residualized using our usual interpretation
 method.
\end_layout

\begin_layout Standard
We resolve reads from memory by walking backwards through the program's
 control-flow graph (CFG) looking for store instructions accessing the same
 symbolic address.
 This walk takes into account both the previous results of interpretation,
 including CFG edges which have been killed and constants which have been
 calculated, as well as the context in which this function is called.
 This effectively implements the alias analysis component of our system,
 though it does not explicitly build a points-to set for each program value
 as most PE alias analyses do.
 We refer to LLPE's use of all local and non-local context as 
\emph on
path-sensitivity
\emph default
.
 This path-sensitive alias analysis improves LLPE's accuracy over PEs conducting
 alias analysis and constant propagation separately, such as Tempo and C-Mix,
 because LLPE can kill the instructions that cause potential aliasing, which
 in turn can lead to better results.
\end_layout

\begin_layout Standard
At control flow merges, most PEs (e.g.
 Tempo or JSpec 
\begin_inset CommandInset citation
LatexCommand cite
key "schultz2003jspec"

\end_inset

) must determine whether the two possible predecessors could have resulted
 in contradictory stores and merge the two.
 However, in LLVM data flow merges are either explicitly expressed by a
 
\family typewriter
phi
\family default
 node, which we interpret by trying to establish a unique live incoming
 value, or else are implied by memory operations.
 Contradictory values stored to memory are naturally handled by our CFG-walk
 approach to resolving memory reads: once store instructions that may define
 a given load are identified, they are resolved just as a phi node merging
 those values.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% LaTeX chokes on lstlisting within subfloat?
\end_layout

\begin_layout Plain Layout


\backslash
newsavebox{
\backslash
figonea}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lrbox}{
\backslash
figonea} % Store first listing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int32 main() {
\end_layout

\begin_layout Plain Layout

	int32 a = 7;
\end_layout

\begin_layout Plain Layout

	int32* b = &a;
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		i = phi(0, k);
\end_layout

\begin_layout Plain Layout

		j = f(b);
\end_layout

\begin_layout Plain Layout

		k = i + j;
\end_layout

\begin_layout Plain Layout

		exit_cond = k < 10;
\end_layout

\begin_layout Plain Layout

	} while(exit_cond)
\end_layout

\begin_layout Plain Layout

	return k;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int32 f(int32* x) {
\end_layout

\begin_layout Plain Layout

	ret = *x;
\end_layout

\begin_layout Plain Layout

	*x = 5;
\end_layout

\begin_layout Plain Layout

	return ret;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{lrbox}
\end_layout

\begin_layout Plain Layout


\backslash
newsavebox{
\backslash
figoneb}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lrbox}{
\backslash
figoneb} % Store second listing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int32 main() {
\end_layout

\begin_layout Plain Layout

	int32 a = 7;
\end_layout

\begin_layout Plain Layout

	int32* b = &a;
\end_layout

\begin_layout Plain Layout

	i_iter1 = 0;
\end_layout

\begin_layout Plain Layout

	ret_f_iter1 = 7;
\end_layout

\begin_layout Plain Layout

	a = 5;
\end_layout

\begin_layout Plain Layout

	j_iter1 = 7;
\end_layout

\begin_layout Plain Layout

	k_iter1 = 7;
\end_layout

\begin_layout Plain Layout

	exit_cond_iter1 = false;
\end_layout

\begin_layout Plain Layout

	i_iter2 = 7;
\end_layout

\begin_layout Plain Layout

	ret_f_iter2 = 5;
\end_layout

\begin_layout Plain Layout

	a = 5;
\end_layout

\begin_layout Plain Layout

	j_iter2 = 5;
\end_layout

\begin_layout Plain Layout

	k_iter2 = 12;
\end_layout

\begin_layout Plain Layout

	exit_cond_iter2 = true;
\end_layout

\begin_layout Plain Layout

	return 12;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{lrbox}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usebox{
\backslash
figonea}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Before LLPE
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:eg1pre"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usebox{
\backslash
figoneb}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
After LLPE
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:eg1post"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
An example program featuring a loop, calls and memory operations, before
 and after application of LLPE.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To give a simple example of LLPE as described so far, Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:eg1pre"

\end_inset

 shows a program involving 2 functions, 
\family typewriter
main
\family default
 and 
\family typewriter
f
\family default
, and Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:eg1post"

\end_inset

 shows the values LLPE computes for each instruction and the straightened
 program structure after the calls to 
\family typewriter
f
\family default
 are inlined and the loop unrolled, but before dead instructions are removed.
\end_layout

\begin_layout Standard
LLPE emits the initializers at input program lines 2 and 3 verbatim, then
 enters the loop at line 4.
 In iteration 1 the phi node on line 5 takes a constant 0; this is emitted
 as output line 4.
 It then enters the call to 
\family typewriter
f
\family default
 at line 6.
\end_layout

\begin_layout Standard
To resolve the load from 
\family typewriter
a
\family default
 within that call, LLPE walks backwards through the body of 
\family typewriter
f
\family default
, then iteration 1 of the loop in 
\family typewriter
main
\family default
, then the loop's predecessor.
 It finds that on this path no store affects 
\family typewriter
a
\family default
 and so the load returns its initializer; this is emitted as output line
 5.
 
\end_layout

\begin_layout Standard
It now knows the return value for this call to 
\family typewriter
f
\family default
 and can calculate the values of 
\family typewriter
k
\family default
 and 
\family typewriter
exit_cond
\family default
, which are emitted as output lines 8-9.
 It finds the loop's exit branch dead and so begins to specialize iteration
 2.
 This proceeds similarly to iteration 1 except that the phi node 
\family typewriter
i
\family default
 takes the previous iteration's value of 
\family typewriter
k
\family default
 (7), and the resolution of the load on line 14 proceeds differently: LLPE
 walks backward through all code emitted so far to find the definition 
\family typewriter
a = 5
\family default
 in the previous call to 
\family typewriter
f
\family default
.
 This is emitted as output line 11.
\end_layout

\begin_layout Standard
Finally LLPE determines that the loop definitely exits this time and proceeds
 to emit output line 16.
 As all instructions are either evaluated to constants or dead (without
 users), the final output program is simply 
\begin_inset Quotes eld
\end_inset


\family typewriter
return 12
\family default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Termination
\end_layout

\begin_layout Standard
The approach so far, if applied naively, would struggle with many input
 programs.
 For example, a recursive function, or a loop controlled by a dynamic branch,
 could result in our specializing an infinite number of procedure calls
 or basic blocks respectively, even if the infinite recursion or loop would
 not be entered at runtime.
\end_layout

\begin_layout Standard
To ensure PE termination, we only permit potentially infinite exploration
 such as this on paths which are 
\emph on
certain
\emph default
 to be executed at runtime.
 We say that a given block is certain if all paths from program entry must
 reach given block (i.e.
 it post-dominates the entry block).
 When a loop iteration or recursive call is not certain we analyse the general
 call or iteration rather than analysing each recursion/iteration individually.
 Thus LLPE will fail to terminate if and only if the input program is certain
 not to terminate, which is typically considered acceptable behavior for
 a PE system 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

.
 To minimize this restriction's impact on LLPE's accuracy, we compute certainty
 taking all available context into account, so infinite loops that in general
 may be bypassed but are certain given the specialization conditions 
\emph on
are
\emph default
 explored.
\end_layout

\begin_layout Subsubsection
Guards
\end_layout

\begin_layout Standard
If a specialized program is executed in an environment that doesn't match
 the specialization conditions, undefined behavior can result.
 For example, if we specialize 
\family typewriter
printf
\family default
 with respect to the format string 
\family typewriter

\begin_inset Quotes eld
\end_inset

%d
\begin_inset Quotes erd
\end_inset


\family default
 and then call it with a different format string at runtime, several results
 are possible.
 The specialized function might work as expected, it might ignore the runtime
 argument outright, or it might combine the two behaviors unpredictably.
\end_layout

\begin_layout Standard
To avoid this undefined behavior we can optionally synthesize a guard.
 LLPE can be used to produce several versions of a program specialized according
 to different assumptions about arguments or other parameters: the guard
 then checks at runtime whether any specialized version is appropriate,
 or else branches to unspecialized code.
\end_layout

\begin_layout Subsection
System Call Support
\end_layout

\begin_layout Standard
We support specialization with respect to a filesystem image, and to this
 end understand file descriptors (FDs) as first-class objects.
 We establish a graph of system calls affecting each symbolic FD, rooted
 at an 
\family typewriter
open
\family default
 call and leading to one or more 
\family typewriter
close
\family default
 calls.
 We discover this system call graph with a path-sensitive analysis similar
 to the load-resolution procedure described in ยง3.1.
 If we can uniquely identify the file name and offset leading into a 
\family typewriter
read
\family default
 call, we can evaluate reads from its buffer at specialization time.
 We can eliminate the entire graph including 
\family typewriter
open
\family default
 and 
\family typewriter
close
\family default
 calls if we have resolved all 
\family typewriter
read
\family default
 users this way.
 Both of these transformations allow us to skip system calls and perhaps
 waits for physical I/O devices at runtime.
\end_layout

\begin_layout Standard
The file system contents might change after specialization but before, or
 during, runtime.
 Specialization with respect to filesystem information which is expected
 to change during execution is unsound and may result in those changes going
 unnoticed at runtime, so we require the user to explicitly nominate files
 and directories that are safe to read.
 When any file or directory is partially read during specialization, we
 emit a guard which checks consistency between the specialization-time and
 runtime versions, using either file modification time or a cheap checksum,
 and if the file has in fact been modified we branch to an unmodified version
 of the program.
\end_layout

\begin_layout Standard
LLPE also understands the side-effects of other system calls: for example,
 we note that 
\family typewriter
clock_gettime
\family default
 writes through both of its arguments and may alter 
\family typewriter
errno
\family default
 but has no other effects, even though of course we can't use the value
 of the system clock at specialization time.
\end_layout

\begin_layout Subsection
Partially Dynamic Values
\end_layout

\begin_layout Standard
Our design so far can only establish single, concrete values for instructions,
 but sometimes 
\emph on
partial
\emph default
 information about a value is useful: for example, in LLVM a pointer derived
 from another by pointer arithmetic must continue to point to the same allocated
 object (global variable, stack allocation or 
\family typewriter
malloc
\family default
 call).
 Knowing a pointer addresses some particular object but not the precise
 offset is still useful, as it bounds the side-effects of stores through
 that pointer.
 We extend our notion of instruction results to include two new kinds of
 information: 
\emph on
value sets
\emph default
, and 
\emph on
fuzzy pointers
\emph default
.
\end_layout

\begin_layout Standard
LLPE can resolve an instruction to a 
\emph on
set
\emph default
 of result values.
 These are produced at phi nodes and other dataflow merges when many definitions
 are possible.
 Arithmetic and bitwise operations can consume and produce value sets: for
 example, 
\family typewriter
{1, 2}
\family default
 + 
\family typewriter
{4, 8}
\family default
 evaluates to 
\family typewriter
{5, 6, 9, 10}.

\family default
 Tracking value sets in this way is similar to the 
\begin_inset Quotes eld
\end_inset

specialization by continuations
\begin_inset Quotes erd
\end_inset

 technique used by some PEs to handle control flow merges by specializing
 the merge block for both possible predecessors (e.g.
 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

).
 However to our knowledge no previous PE for C-like low-level languages
 calculates set values across the entire input program.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},framexleftmargin={1.5em},numbers=left,tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

int32 main(int32 unknown) {
\end_layout

\begin_layout Plain Layout

	test = (unknown == 1);	// ?
\end_layout

\begin_layout Plain Layout

	vague = test ? 0 : 1;	// {0, 1}
\end_layout

\begin_layout Plain Layout

	certain = vague & 2;	// 0
\end_layout

\begin_layout Plain Layout

	return certain;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
Example program illustrating value sets: whilst 
\family typewriter
vague
\family default
 might take more than one value, 
\family typewriter
certain
\family default
 is nonetheless assigned a single value.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:valset"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:valset"

\end_inset

 gives a simple example showing how tracking value sets per instruction
 can improve specialization opportunities.
 In this example a set is created (line 3) but later resolved into a single
 value by masking out the uncertainty (line 4).
 In order to avoid an explosion in the time and space needed for specialization,
 once a value set grows larger than a user-controllable threshold it is
 considered wholly unknown.
 This threshold can be adjusted to trade memory consumption for quality
 of specialization.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},framexleftmargin={1.5em},numbers=left,tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

int32 main(int32 dyn) {
\end_layout

\begin_layout Plain Layout

	int32 x[10];
\end_layout

\begin_layout Plain Layout

	int32 y = 1;
\end_layout

\begin_layout Plain Layout

	certain_ptr = x + 5;  // &(x[5])
\end_layout

\begin_layout Plain Layout

	fuzzy_ptr = x + dyn;  // &(x[?])
\end_layout

\begin_layout Plain Layout

	*certain_ptr = 2;
\end_layout

\begin_layout Plain Layout

		// Modifies x[5] only
\end_layout

\begin_layout Plain Layout

	*fuzzy_ptr = 3;
\end_layout

\begin_layout Plain Layout

		// Modifies entire array
\end_layout

\begin_layout Plain Layout

	unresolved = *certain_ptr;
\end_layout

\begin_layout Plain Layout

		// ?.
 Store of 3 interferes
\end_layout

\begin_layout Plain Layout

	resolved = y;
\end_layout

\begin_layout Plain Layout

		// 1.
 No store interferes
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
Example program illustrating fuzzy pointers: We know 
\family typewriter
fuzzy_ptr
\family default
 points somewhere in the array 
\family typewriter
x
\family default
, preventing us from resolving 
\family typewriter
*certain_ptr
\family default
 but providing enough information that we know 
\family typewriter
y
\family default
 is unmodified at the end.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:fuzzyptr"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A special case of a value set is a 
\emph on
fuzzy pointer
\emph default
: this is a pointer whose base object is known, but whose offset within
 that object is not.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:fuzzyptr"

\end_inset

 gives an example in which a known pointer is indexed by a dynamic offset
 (line 5) and then stored to (line 8).
 We know that writing through 
\family typewriter
fuzzy_ptr
\family default
 does not affect the read from 
\family typewriter
y
\family default
 on line 12, even though its precize value is uncertain.
\end_layout

\begin_layout Standard
Previous PEs targeting C-like languages typically ran an alias analysis
 pre-pass to calculate a points-to set for all pointers, which in LLPE correspon
ds to a set of fuzzy pointers.
 The advantage of our approach is that we can take the results of interpretation
 so far into account because our alias analysis is interleaved with the
 PE process, meaning we can calculate smaller points-to sets and so improve
 specialization.
 We are also much better placed to name specific heap and stack allocations
 rather than conflating them based on call-site as is commonly done in other
 systems 
\begin_inset CommandInset citation
LatexCommand cite
key "schultz2003jspec,consel1996tempobasic"

\end_inset

.
\end_layout

\begin_layout Subsection
Dynamic Loops and Calls
\end_layout

\begin_layout Standard
Clearly interesting programs will sometimes feature loops which cannot be
 exhaustively explored at specialization time, either for lack of information
 or because we refrained from exploring the loop due to our termination
 constraints (ยง3.1.1).
 The following describes our strategy for establishing useful facts about
 such unbounded loops.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},framexleftmargin={1.5em},numbers=left,tabsize=3,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

int32 main(int32* p, int32* end) {
\end_layout

\begin_layout Plain Layout

	int32 x = 5;
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		y = phi(p, next_y)	// &(p[?])
\end_layout

\begin_layout Plain Layout

		(*y) = 0;
\end_layout

\begin_layout Plain Layout

		next_y = y + 1;		// &(p[?])
\end_layout

\begin_layout Plain Layout

		exit = (next_y == end);	// ?
\end_layout

\begin_layout Plain Layout

	} while(!exit)
\end_layout

\begin_layout Plain Layout

	return x;						// 5
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
An example program illustrating the value of loop invariant analysis.
 Whilst we can't explore every iteration of the unbounded loop, we establish
 
\family typewriter
y
\family default
 and 
\family typewriter
next_y
\family default
 point into 
\family typewriter
p
\family default
 as an invariant, and external 
\family typewriter
p
\family default
 must differ from local 
\family typewriter
x
\family default
.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:unboundloop"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:unboundloop"

\end_inset

 we show an unbounded loop that writes to an array.
 Our simple strategy of following the program's dynamic execution flow like
 an interpreter is inadequate here, because we don't know how many times
 the loop will iterate.
 Instead, we try to establish general properties of the loop body, such
 as that only the array 
\family typewriter
p
\family default
 is modified by the write on line 5, and so 
\family typewriter
x
\family default
 retains its old value when read at line 9.
\end_layout

\begin_layout Standard
Our loop invariant analysis includes considering function calls within an
 invariant context.
 For example, if the program in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:unboundloop"

\end_inset

 defined a trivial function 
\family typewriter
f(a, b) { *a = b; }
\family default
 and called 
\family typewriter
f(ptr, 0)
\family default
 within the loop, we would draw the same conclusions about the loop's side-effec
ts.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:callinloop"

\end_inset

 shows a more complex example program that illustrates how our loop invariant
 analysis investigates calls and subloops nested within the loop under considera
tion.
 We are able to establish as an invariant of the loop beginning at 
\family typewriter
main
\family default
 line 5 that every call to 
\family typewriter
bset
\family default
 only modifies the array 
\family typewriter
buf
\family default
 by showing that for every call, and every iteration of the loop in 
\family typewriter
bset
\family default
, 
\family typewriter
this_p
\family default
 (
\family typewriter
bset
\family default
 line 5) points into 
\family typewriter
buf
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},framexleftmargin={1.5em},numbers=left,tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

void main(int32 unk) {
\end_layout

\begin_layout Plain Layout

	int32 nbytes = unk * unk;
\end_layout

\begin_layout Plain Layout

	int8 buf[nbytes];
\end_layout

\begin_layout Plain Layout

	int8* ptr = buf;
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		c = phi(0, next_c);
\end_layout

\begin_layout Plain Layout

		bset(&ptr, unk);
\end_layout

\begin_layout Plain Layout

			// Only modifies buf
\end_layout

\begin_layout Plain Layout

		next_c = c + 1;
\end_layout

\begin_layout Plain Layout

		exit = (next_c == unk);
\end_layout

\begin_layout Plain Layout

	} while (!exit);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},framexleftmargin={1.5em},numbers=left,tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

void bset(int8* p, int32 n) {
\end_layout

\begin_layout Plain Layout

	end = p + n;				
\end_layout

\begin_layout Plain Layout

		// &(buf@main[?])
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		this_p = phi(p, next_p);	
\end_layout

\begin_layout Plain Layout

			// &(buf@main[?])
\end_layout

\begin_layout Plain Layout

		*this_p = 0;
\end_layout

\begin_layout Plain Layout

		next_p = this_p + 1;			
\end_layout

\begin_layout Plain Layout

			// &(buf@main[?])
\end_layout

\begin_layout Plain Layout

		exit = (next_p == end);
\end_layout

\begin_layout Plain Layout

	} while (!exit);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\emph on
An example program illustrating exploring a function in a loop-invariant
 context.
 We successfully prove that every call to 
\family typewriter
bset
\family default
 within the left-hand loop writes only to the buffer 
\family typewriter
buf
\family default
 declared in 
\family typewriter
main
\family default
, limiting the side-effects of the unbounded loop.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:callinloop"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike the scenarios considered so far, reasoning about unbounded loops
 requires LLPE to resolve circular dependencies between instructions, such
 as 
\family typewriter
y
\family default
 and 
\family typewriter
next_y
\family default
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:unboundloop"

\end_inset

.
 We resolve the dependency using a standard fixpoint method, repeatedly
 lowering in-loop instructions' results' precision until a consistent solution
 if found.
 Lowering precision here means adding more values to a set-typed result,
 or downgrading an exact pointer to a fuzzy pointer, or replacing any result
 with an entirely unknown value.
 This process always terminates, because value sets have an upper size limit,
 meaning each value can only be downgraded a finite number of times, and
 because only a finite number of instructions are considered.
\end_layout

\begin_layout Subsection
Context-insensitive Analysis
\end_layout

\begin_layout Standard
Investigating every function call and loop iteration as described so far
 can be very expensive, as in order to take local PE results into account
 we effectively re-establish general properties of loops and functions each
 time they are entered or called.
 To make our program analysis faster and thus better suited to large programs,
 we introduce a context-insensitive characterization of functions' memory
 side-effects.
\end_layout

\begin_layout Standard
We calculate for each function a modification set: this is a set of modified
 locations, defined in terms of the function's pointer-typed arguments,
 global variables and escaping heap allocations.
 Sub-calls to other functions are represented as an inclusion along with
 a substitution: for example, if function f has two pointer-typed parameters,
 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
, and modifies 
\family typewriter
x
\family default
 but then calls itself recursively with the parameters reversed, we represent
 it as modifying 
\family typewriter
x
\family default
, plus its own modification set under the substitution 
\family typewriter
[x/y, y/x]
\family default
.
 Once all functions are so characterized, we have a recurrence relation
 between functions' modification sets.
 We solve by iterating the inclusion and substitution of other functions'
 sets of modified locations.
\end_layout

\begin_layout Standard
The upshot of this pre-pass is that when later resolving memory reads using
 the path-sensitive alias analysis described in ยง3.1, we can use a function's
 modification set to quickly skip over parts of the call graph.
\end_layout

\begin_layout Subsection
Program Annotations
\end_layout

\begin_layout Standard
LLPE can sometimes under-specialize programs (that is, miss specialization
 opportunities) when it avoids exploring functions or loops to ensure specialize
r termination.
 It can also sometimes over-estimate the memory side-effects of functions
 or loops, either as a consequence of under-specialization, when specialization
 would eliminate side-effecting instructions, or due to system calls or
 inline assembly is does not understand.
 To address both these cases, we support simple, expressive program annotations
 which the user can apply to improve specialization results.
 The available annotations are:
\end_layout

\begin_layout Standard

\series bold
\emph on
Always/never explore
\series default
\emph default
: override LLPE's heuristics and always/never explore calls to a particular
 function.
\end_layout

\begin_layout Standard

\series bold
\emph on
Assume edge taken
\series default
\emph default
: this authorizes the specializer to analyse calls and loops downstream
 of the assumed edge as aggressively as if the edge was certain to be taken.
 It does not render the output incorrect if the branch goes the other way
 at runtime, but could cause PE non-termination.
 This is useful when the programmer expects the program to take a particular
 branch, or knows the code the edge leads to can be explored fully without
 risking non-termination.
 Loops can be similarly annotated to assume that they always exit via a
 particular edge, authorising exploration of further iterations whenever
 that edge is not taken.
\end_layout

\begin_layout Standard

\series bold
\emph on
Annotating side-effects
\series default
\emph default
: when LLPE cannot automatically characterize a function's side-effects
 the user can define them in terms of its arguments.
\end_layout

\begin_layout Standard
At present these side-effects must be described in terms of LLVM functions,
 basic blocks and instructions, but we plan to allow C source annotations
 to convey the same information in a more user-friendly way.
\end_layout

\begin_layout Subsection
Residual program generation
\end_layout

\begin_layout Standard
LLPE analyses its input program in its entirety before writing any of the
 specialized program.
 This means it can decide whether to emit specialized versions of loops
 and functions in the full knowledge of how many instructions can be eliminated
 and will be residualized.
 We decide whether to emit a specialized version of a function or loop by
 weighing the time we expect to save at runtime due to work done at specializati
on time against the code size increase due to residual instructions in the
 specialized function or loop.
 We also take into account that not specializing a function or loop prevents
 us from specializing sub-loops and functions, and therefore calculate these
 cost/benefit scores from the bottom up.
 The algorithm can be tuned by assigning weights to eliminated and residual
 instructions.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
We have implemented a prototype that includes most features of our design.
 We have not yet implemented the context-insensitive analysis step, which
 we approximate by investigating every call-site independently at the cost
 of some analysis time and memory.
\end_layout

\begin_layout Standard
LLPE is implemented as an LLVM 2.8 program analysis/transformation pass.
 We use and adapt many existing LLVM analyses and transformations, including
 their implementation of sparse conditional constant propagation (SCCP)
 and their basic alias analysis.
\end_layout

\begin_layout Subsection
Implementing PE
\end_layout

\begin_layout Standard
We assume that all functions used in the PE input program are defined (i.e.
 the function body is available for analysis), with the exception of system
 calls.
 This is typically achieved by running the specializer against a fully staticall
y linked program; however LLPE does not in principle preclude using shared
 objects in the final binary, as library functions could be externalized
 post-analysis and dynamically re-linked at runtime.
 However our prototype does not currently implement this functionality.
\end_layout

\begin_layout Standard
To specialize a program we start at a nominated entry function (for C programs
 this should be 
\family typewriter
libc_main
\family default
 rather than 
\family typewriter
main
\family default
, to take library initialization into account), then walk the program's
 interprocedural control flow graph (CFG) evaluating instructions as described
 in our design above.
\end_layout

\begin_layout Standard
In parts of the program that can be topologically ordered (i.e.
 acyclic subgraphs of the CFG), we visit basic blocks in topological order
 to ensure that all instructions are evaluated after their arguments.
 In cyclic parts of the program we track dependencies between instructions
 and re-analyse instructions whenever their dependencies are updated until
 a fixed point is reached.
\end_layout

\begin_layout Standard
We represent the program as a tree of 
\emph on
contexts
\emph default
.
 A context corresponds to a function call or a loop which is being investigated
 on a per-iteration basis within its parent context.
 These contexts provide a convenient way to name a specific execution of
 an instruction, which we use to refer to a particular dynamic stack or
 heap allocation, rather than conflating allocations at a particular callsite:
 for example, an instruction / context pair can express the notion of a
 particular allocation when called in a particular loop iteration in the
 context of a particular stack of function calls.
\end_layout

\begin_layout Standard
We borrow LLVM's standard 
\family typewriter
loops
\family default
 analysis to determine a tree of loops each of which is characterized by
 a unique header block which dominates the rest of the loop, and a single
 backedge.
 This structure is convenient for describing loops and cheaply determining
 when they do and do not iterate.
 When loop-like structures exist that lack these properties we use a somewhat
 augmented version of LLVM's standard 
\family typewriter
loopsimplify
\family default
 pass, which automatically simplifies all cyclic CFGs to fit this tree-of-simple
-loops form.
\end_layout

\begin_layout Standard
We do not begin emitting a residual program until LLPE's analysis phase
 is complete.
 This means that we must be able to store the complete graph of integration
 contexts in memory, which currently limits the scale of program we can
 currently handle.
 The memory usage for specialisation scales as a copy of each function per
 callsite when we cannot straight-line loops, and scales as the number of
 dynamically executed instructions when we can straighten all loops.
 We defer managing memory usage for analysis of large programs to future
 work, but expect to use techniques such as sharing analysis results across
 call-sites and finding partitions in the program suitable for separate
 analysis.
\end_layout

\begin_layout Subsection
Language Coverage
\end_layout

\begin_layout Standard
The current LLPE implementation achieves very high coverage of the LLVM
 intermediate language.
 We support many language constructs which are typically omitted from PEs
 because they are too difficult to implement (e.g.
 C-Mix omits all treatment of heap memory 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix"

\end_inset

, and JSpec conflates all objects allocated at a call-site for lack of names
 for individual allocations 
\begin_inset CommandInset citation
LatexCommand cite
key "schultz2003jspec"

\end_inset

).
\end_layout

\begin_layout Standard
Specifically, we are able to specialize programs featuring:
\end_layout

\begin_layout Itemize
Pointer arithmetic, so long as it is restricted to addition, subtraction,
 comparison, and examination of the lower bits of a pointer that are determined
 by its alignment.
 Pointers can be compared arbitrarily with other pointers that have a common
 base object, and compared for equality whether they have a common base
 or not.
\end_layout

\begin_layout Itemize
Reads from dynamically allocated memory (from 
\family typewriter
malloc
\family default
 or a similar heap allocator).
\end_layout

\begin_layout Itemize
Reads whose results depend on target-specific struct layout, array alignment
 and similar.
 This is possible because LLVM IR explicitly encodes the target-specific
 layout and alignment rules which will be used when lowering to assembly.
\end_layout

\begin_layout Itemize
Reads that are defined by writes of a different type (e.g.
 2 
\family typewriter
int16
\family default
 stores that define an 
\family typewriter
int32
\family default
 load).
\end_layout

\begin_layout Standard
Our coverage is not 100% however, and LLPE's analysis must make conservative
 assumptions when programs use pointer arithmetic not covered above.
 We do not support arbitrary inspection of the high bits of a pointer, as
 a hash table might use to determine the pointer's hash bucket, or comparison
 of pointers without a common base as might be used to sort an array of
 pointers.
 Our support for data reinterpretation is limited to non-pointer types,
 again because we don't know anything about their numerical values at specializa
tion time, but we could improve support here by including 
\family typewriter
malloc
\family default
 in the domain of specialization and modeling the behavior of memory allocation
 system calls.
\end_layout

\begin_layout Standard
We also currently do not support either exceptions or inline assembly, although
 the impact of this limitation is minimized because we support 
\family typewriter
memset
\family default
, 
\family typewriter
memcpy
\family default
 and 
\family typewriter
memmove
\family default
 as intrinsics.
 We do not expect exception support to be difficult to implement since LLVM
 exceptions are semantically similar to an ordinary call instruction followed
 by a condition branch.
 We could improve our understanding of inline assembly using an LLVM disassemble
r, which currently exist for x86 and ARM architectures.
\end_layout

\begin_layout Standard
All of these unsupported instructions currently result in a residualized
 instruction and an unknown value that can limit further specialization
 depending on how it is used.
\end_layout

\begin_layout Subsection
Post-processing
\end_layout

\begin_layout Standard
After the main PE phase has completed, LLPE runs a series of cleanup passes
 over the program to be emitted.
 These are conceptually separate from PE, in that they do not use the detailed
 analysis that drives PE and can be run entirely separately, but they are
 important to fully realise the benefits of PE and are included in our evaluatio
n results below.
\end_layout

\begin_layout Standard
Post-PE cleanup passes are used to eliminate dead stores (i.e.
\begin_inset space \thinspace{}
\end_inset

store instructions which cannot possibly be read), dead allocation sites
 including 
\family typewriter
malloc
\family default
 / 
\family typewriter
realloc
\family default
 / 
\family typewriter
free
\family default
 graphs that no longer have users, dead global variables, and 
\family typewriter
open
\family default
 / 
\family typewriter
close
\family default
 calls that are not otherwise used.
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard
We evaluated our prototype specializer in experiments specializing 3 programs
 from the GNU Coreutils (
\family typewriter
date
\family default
, 
\family typewriter
printf
\family default
 and 
\family typewriter
md5sum
\family default
), an XML utility called 
\family typewriter
xmlstar
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
http://xmlstar.sourceforge.net/
\end_layout

\end_inset

, which uses the large 
\family typewriter
libxml2
\family default
 and 
\family typewriter
libxslt
\family default
 libraries, and a small webserver called Mongoose
\begin_inset Foot
status open

\begin_layout Plain Layout
http://code.google.com/p/mongoose/
\end_layout

\end_inset

.
 We will describe them in increasing order of the difficulty of specialization.
 Tables 1-4 summarize the code size reductions and runtime improvements
 achieved for the Coreutils and 
\family typewriter
xmlstar
\family default
, giving the sizes for each program as stored on disk (labeled 
\begin_inset Quotes eld
\end_inset

Stored
\begin_inset Quotes erd
\end_inset

), as well as the size of their text, rodata and bss segments, representing
 the elimination of code, constant data and global variables respectively.
 All figures are rounded to the nearest kilobyte, millisecond or microsecond,
 and the improvement percentages are given to one decimal place.
 Running times were measured from entering 
\family typewriter
_start
\family default
 to calling 
\family typewriter
exit
\family default
 for the Coreutils, because their runtimes are ordinarily very short and
 are dominated by the cost of process creation, and are given as the mean
 across 10,000 runs ยฑ standard deviation.
 The running time for 
\family typewriter
xmlstar
\family default
 is measured from the time 
\family typewriter
exec
\family default
 is called to the return of a corresponding 
\family typewriter
wait
\family default
 call, and is given as mean milliseconds across 50,000 runs.
 The standard deviation was negligible.
\end_layout

\begin_layout Standard
All experiments in this section were performed using static binaries linked
 against 
\family typewriter
uclibc
\family default
, and performance measurements were taken on an otherwise-unloaded machine
 with an AMD Phenom II X4 925 processor and 4GB of main memory.
\end_layout

\begin_layout Subsection
Coreutils and Xmlstar
\end_layout

\begin_layout Standard
Firstly, and most simply, we specialized 
\family typewriter
md5sum
\family default
 with respect to its command-line and the contents of the file it digests.
 The specialization conditions almost completely determine the program's
 behavior at runtime, and so LLPE can reduce the input program to straight-line
 code for the most part, but we still must residualize code that describes
 
\family typewriter
md5sum
\family default
's behavior when 
\family typewriter
malloc
\family default
 or writes to the console fail.
 In this respect even a notionally easy case of partial evaluation beats
 manual specialization, which would likely not preserve that error behavior
 and so may break the assumptions of programs consuming its result.
 This program also demonstrates our partial evaluation with respect to VFS
 system calls, which are used to read the input file.
 The input was kept to around 5KB in size so that the actual MD5 runtime
 was of similar size to the startup/shutdown overhead.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialized
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
241kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.1%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22.2%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
219kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
211kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.5%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
213 ยฑ 12us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98 ยฑ 9us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54.0%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
md5sum
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialized
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
284kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
255kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.1%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35.8%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
221kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
214kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.8%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.8%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
159 ยฑ 16us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86 ยฑ 8us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45.9%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
printf
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialized
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
301kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
241kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.8%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
69kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64.4%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
215kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.5%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.9%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
237 ยฑ 10us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
131 ยฑ 9us
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44.7%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
date
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Original
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specialized
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reduction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stored
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1778kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
272kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84.7%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.text
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1741kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
258kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
85.2%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.rodata
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80.7%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.bss
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13kb
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60.2%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.43ms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.75ms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28.0%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results for 
\family typewriter
xmlstar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
md5sum
\family default
's code size does not fall much because the implementation of the MD5 algorithm
 is quite small.
 The residual code is mostly part of the 
\family typewriter
stdio
\family default
 library, used to print the now-known result to stdout.
 The runtime improvement is large as expected, since no MD5 actually needs
 to be calculated: the remaining work is entirely console-printing system
 calls and error checking.
\end_layout

\begin_layout Standard
We specialized 
\family typewriter
printf
\family default
 with respect to its environment, which sets the LC family of locale variables,
 and partially with respect to its command line: we specify that its first
 argument is 
\family typewriter

\begin_inset Quotes eld
\end_inset

%d %s
\begin_inset Quotes erd
\end_inset


\family default
 and that the total number of arguments is (appropriately) 3, but leave
 the other two arguments unspecified.
 This produces a 
\family typewriter
printf
\family default
 program which renders exactly one number and then one string, allowing
 us to discard formatting code for other types.
 We could use a specialized printf like this if we found a shell script
 that calls 
\family typewriter
'/usr/bin/printf 
\begin_inset Quotes eld
\end_inset

%d %s
\begin_inset Quotes erd
\end_inset

 $1 $2'
\family default
.
 Because the exact values of the integer and string arguments are unknown,
 LLPE cannot simply produce straight-line code as for 
\family typewriter
md5sum
\family default
, but must residualize loops that implement integer-to-string conversion
 and writing an arbitrary string to a stdio stream, amongst others.
 To justify propagating knowledge of the static format string throughout
 the program LLPE must prove that the residual stdio calls do not overwrite
 that string, and in particular we show that they never modify any location
 but the structures and buffers allocated in 
\family typewriter
fopen
\family default
 calls or preallocated for standard streams.
\end_layout

\begin_layout Standard
Code size reduction is achieved by eliminating several functions in the
 
\family typewriter
printf
\family default
 family as all invocations are successfully reduced to formatters for a
 particular type.
 The runtime reduction is significant: whilst we still need to perform integer-t
o-string conversion at runtime, we benefit from eliminating the format string
 parsing stage, and from collapsing the many nested parsers that implement
 
\family typewriter
printf
\family default
 into one.
 We may also realize benefits from eliminating dead code from the 
\family typewriter
printf
\family default
 parser, thus saving i-cache space, but we do not have concrete data to
 back this up.
\end_layout

\begin_layout Standard
We specialized 
\family typewriter
date
\family default
 with respect to its environment, which sets locale variables as for 
\family typewriter
printf
\family default
, and its command line, which is empty.
 It is also specialized with respect to files giving the local system's
 preferred timezone.
 This yields a date program which is specialized to display the time (discarding
 its other functions such as setting the time) in a particular timezone
 and with the program's default format.
 The actual time that will be printed remains dynamic.
 This presents similar challenges to printf above, since emitting an unknown
 date string yields unbounded integer-printing and stdio-writing loops in
 the same way as 
\family typewriter
printf
\family default
's unknown 
\family typewriter
%d
\family default
 parameter, but adds the challenge of analysing filesystem-related system
 calls.
\end_layout

\begin_layout Standard
Code size reduction here was larger than for 
\family typewriter
printf
\family default
 because we could also eliminate code that is only used for the date program's
 other functions, such as setting the system clock.
 Runtime reduction resulted from the elimination of computation as for the
 previous two examples, but also from completely eliminating the system
 calls used to read timezone data.
\end_layout

\begin_layout Standard
We specialized 
\family typewriter
xmlstar
\family default
 specifying all of its command-line arguments to evaluate an XPath expression
 against a 5-line XML document.
 This information allows the specializer to evaluate the parse of the XML
 document input, conversion of the XPath expression into an XSLT stylesheet,
 parsing of that stylesheet, and the application of the stylesheet to the
 input document.
 We eliminate most of the computation and memory allocation of these parse
 stages, but some remains because 
\family typewriter
libxml2
\family default
 and 
\family typewriter
libxslt
\family default
, which 
\family typewriter
xmlstar
\family default
 uses internally, uses both hash values derived from pointers and sorting
 of pointers, neither of which we can evaluate due to our ignorance of pointers'
 numerical values.
\end_layout

\begin_layout Standard
A huge improvement in code size results because we are able to convert the
 function pointers that are used throughout 
\family typewriter
libxml2
\family default
 and 
\family typewriter
libxslt
\family default
 into direct calls.
 This results in a large number of dead functions which can be discarded.
 This likely improves runtime as well, because direct calls are much more
 amenable to further conventional optimization.
\end_layout

\begin_layout Standard
A caveat to our results for Coreutils and 
\family typewriter
xmlstar
\family default
 is that we supplied a small number of annotations to improve specialization
 results.
 We used the 
\emph on
assume-edge-taken
\emph default
 annotation when LLPE was uncertain about a particular branch and so stopped
 early rather than aggressively explore successor blocks.
 We gave it this hint when manual inspection revealed that one path was
 in fact very rare (e.g.
 a 
\family typewriter
malloc
\family default
 failure branch), and exploring the other path as aggressively as if it
 was a known certainty was reasonable (recall from ยง3.6 that annotations
 like these can cause specializer non-termination, but do not threaten correctne
ss).
 We required between 1 and 5 such annotations for each program.
 We defer to future work improving our heuristics for searching for specializati
on opportunities to match these results with no manual annotation at all.
\end_layout

\begin_layout Subsection
Mongoose
\end_layout

\begin_layout Standard
Mongoose is a small webserver, implemented as 5000 lines of C.
 We had to modify it to accommodate current limitations of LLPE: because
 we do not yet support multi-threaded or multi-process programs, we omitted
 its usual 
\family typewriter
accept
\family default
-thread / worker-thread structure and instead used a single thread to service
 one connection at a time.
 We also disabled its support for CGI and SSI, both of which spawn and communica
te with external processes.
 We simplified its HTTP request dispatch function to eliminate some paths
 which, whilst conceptually simple, were extremely time-consuming to analyse;
 we discuss our strategy for overcoming this limitation in Section 6.
 Finally we annotated the 
\family typewriter
snprintf
\family default
 and 
\family typewriter
sscanf
\family default
 functions' side-effects, because LLPE could not fully characterize their
 side-effects when occurring in an unbounded loop.
 We are confident that small improvements to LLPE will allow us to remove
 these side-effect annotations in the near future.
\end_layout

\begin_layout Standard
We specialized the simplified Mongoose with respect to its command-line,
 specifying a single port to listen on and not specifying any more complex
 options such as enabling HTTP authentication, or URL rewriting rules.
 The analysis is quite different to any case discussed so far, because whilst
 prior programs could be broadly analysed as straight-line code separating
 small loops, here an infinite 
\family typewriter
poll
\family default
/
\family typewriter
accept
\family default
 loop surrounds practically the entire program, meaning we must analyse
 what is effectively one big unbounded loop.
\end_layout

\begin_layout Standard
The main specialization opportunity here is to take the configuration specified
 by the command-line and propagate that information into the main request
 dispatch loop, eliminating checks for URL rewriting, password protection
 and the like.
 To exploit this opportunity, LLPE must bound the side-effects for the entire
 dispatch loop, and modulo the caveats above, successfully does so.
 We evaluate the benefit of doing so by comparing the time to make 10,000
 HTTP GET requests from a local client in a tight request loop.
 We find that the optimized Mongoose takes on average 7.3% faster (taking
 4.60s vs.
 4.96s to complete the 10,000 requests).
 The resulting binary is however somewhat larger (389kb vs.
 327kb, an increase of 19%) due to inlining of specialized copies of calls.
 The speedup is modest in this case because most of the work of serving
 a file over HTTP remains to be done at runtime.
 Nonetheless our ability to specialize within the dispatch loop at all illustrat
es LLPE's ability to function effectively even on highly challenging programs
 such as network servers.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
Going forward with LLPE, we will improve specialization efficiency, develop
 our heuristics for automatically exploring programs, add support for programs
 that conduct IPC and threading, and finally integrate LLPE into a whole-system
 automated specializer.
\end_layout

\begin_layout Standard
We mentioned whilst describing our Mongoose experiment that we were forced
 to simplify the input program to reduce specialization time to practical
 levels.
 This problem stemmed from our very aggressive alias analysis taking too
 long to run in the context of a loop where it effectively degrades into
 a path-insensitive analysis.
 We plan to improve our alias analysis' behavior in these circumstances
 by switching between path-sensitive and path-insensitive analysis based
 on a heuristic estimate of the likely trade-off of accuracy for time.
 At a more fundamental level we plan to use the online-offline mixed PE
 approach 
\begin_inset CommandInset citation
LatexCommand cite
key "sumii1999efficientonlinepe"

\end_inset

 to dramatically speed up LLPE.
\end_layout

\begin_layout Standard
Another problem we encountered in our experiments was the need to occasionally
 annotate programs to enable aggressive specialization of code we weren't
 certain would execute.
 We will improve LLPE's heuristics for determining when it is appropriate
 to specialize code after an uncertain branch by recognising common error
 conditions (such as 
\family typewriter
malloc
\family default
 failure), attempting to prove loop termination where this is cheaper than
 full specialization, and using profiling of the target program to inform
 our specialization choices.
\end_layout

\begin_layout Standard
We will implement specialization of programs with respect to assumptions
 about their interactions with external programs and systems.
 We can extend our Mongoose experiment by specializing against assumptions
 about network input, such as that all requests are GET requests, described
 as a constraint on the bytes read from accepted sockets.
 Along similar lines we will implement specialization of programs with respect
 to assumptions about standard input or other pipes.
 This would enable us to specialize a pipeline found in a shell script by
 evaluating the first program to establish facts about its output, specialize
 the second according to those facts, yielding facts about that second program's
 output, and so on.
\end_layout

\begin_layout Standard
We will also implement support for specializing concurrent programs.
 PE of concurrent programming languages has been investigated in toy languages
 similar to CSP 
\begin_inset CommandInset citation
LatexCommand cite
key "marinescu1997conc"

\end_inset

, and we intend to investigate how far its lessons can be extended to deal
 with e.g.
 programs using pthreads.
\end_layout

\begin_layout Standard
We intend to use LLPE to create a whole-system specializer.
 Working in an all-LLVM ecosystem, we will use lightweight profiling to
 map all processes created on a system and use this information to inform
 profitable specialization: for example, we might notice that a program
 is frequently used with the same arguments, or that it spends a lot of
 time reading a particular file which rarely changes.
 We could then use system idle time to construct a specialized version of
 the program.
 
\end_layout

\begin_layout Standard
We can produce several different specialized versions of a program, or several
 guarded specializations of functions within the program, if profiling indicates
 that the speed gains from accelerating several different paths is worth
 the extra space required to store more than one specialized program or
 subprogram.
 In all cases the original, unspecialized program will be retained for use
 when no specialized version is appropriate.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
Partial evaluators have been developed for both functional languages such
 as Lisp 
\begin_inset CommandInset citation
LatexCommand cite
key "beckman1976lisp"

\end_inset

 and Scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "berlin1990scheme1,weise1991fusescheme"

\end_inset

, and for imperative languages including Fortran 
\begin_inset CommandInset citation
LatexCommand cite
key "baier1994fortran"

\end_inset

, C 
\begin_inset CommandInset citation
LatexCommand cite
key "andersen1994cmix,consel2004tour"

\end_inset

 and Java 
\begin_inset CommandInset citation
LatexCommand cite
key "affeldt2002javaruntime,schultz2003jspec,shali2011hybridpe"

\end_inset

.
 For a more complete roundup of partial evaluators see reviews 
\begin_inset CommandInset citation
LatexCommand cite
key "beckmann1996partial,jones1996introduction"

\end_inset

.
\end_layout

\begin_layout Standard
The PE systems below are divided into online and offline PEs.
 Offline PEs decide which input program instructions can be evaluated at
 specialization time given only a 
\emph on
division
\emph default
 of the arguments into those which will be defined at specialization time
 and those which will only be supplied at runtime, whilst online PEs use
 knowledge of the specialized arguments' values as well 
\begin_inset CommandInset citation
LatexCommand cite
key "jones1996introduction"

\end_inset

.
 As such online PE systems are usually more accurate than offline ones,
 but online specialization is usually more costly 
\begin_inset CommandInset citation
LatexCommand cite
key "christensen2004offvsonline"

\end_inset

.
\end_layout

\begin_layout Subsection
C-Mix
\end_layout

\begin_layout Standard
The partial evaluators C-mix 
\begin_inset CommandInset citation
LatexCommand cite
key "makholm1999cmix2,andersen1994cmix"

\end_inset

 and Tempo 
\begin_inset CommandInset citation
LatexCommand cite
key "consel2004tour"

\end_inset

 have made the most progress in specializing complete C programs.
 C-mix targets the full C language; however, it conservatively residualizes
 code featuring difficult-to-analyse constructions such as pointer arithmetic
 and type puns achieved by pointer casting or union types.
\end_layout

\begin_layout Standard
It is conservative when selecting which statements and expressions can be
 evaluated at specialization time: whilst it does specialize functions per
 static callsite, at an intraprocedural level it will residualize all uses
 of variables which are at any point assigned dynamic values or fall under
 dynamic control.
 Other limitations include a lack of support for heap allocated memory,
 the possibility of specializer non-termination on source programs which
 themselves always terminate, and the need to annotate external functions'
 side-effects and global variables' visibility to other translation units.
 The latter limitation arises because most C programs are compiled by separate
 compilation of translation units within a program and pre-compiled libraries.
\end_layout

\begin_layout Standard
The authors of C-Mix achieved up to 50% reduction in runtime at the cost
 of sometimes-significant code size increase specializing a 10KLOC raytracer
 with respect to its scene description.
 Others 
\begin_inset CommandInset citation
LatexCommand cite
key "jung2005cmix2user"

\end_inset

 have also used C-Mix and achieved up to 60% code size reduction evaluating
 an operating system kernel with respect to its configuration.
\end_layout

\begin_layout Subsection
Tempo
\end_layout

\begin_layout Standard
Tempo is another offline PE, but unlike C-Mix is capable of operating both
 ahead of time and at runtime.
 It is more accurate than C-Mix 
\begin_inset CommandInset citation
LatexCommand cite
key "hornof1997tempobta"

\end_inset

, permitting it to execute computations at specialization time even when
 variables involved are sometimes under dynamic control.
 However it conflates iterations of loops and recursive procedure calls
 in order to guarantee specializer termination.
 
\end_layout

\begin_layout Standard
Unlike C-Mix, Tempo was explicitly designed for systems applications, and
 has been evaluated in many real-world scenarios, including specializing
 RPC serialization routines with respect to the data type that will be serialize
d 
\begin_inset CommandInset citation
LatexCommand cite
key "mcnamee2001temporpcbpf"

\end_inset

, a Berkeley Packet Filter interpreter with respect to its program, and
 a Java bytecode interpreter with respect to its input program.
 
\end_layout

\begin_layout Standard
Whilst these applications are important successes, and exhibit Tempo's maturity
 as a practical tool, it shares C-Mix's limitations when dealing with separate
 compilation and when dealing with heap-allocated memory: Tempo's alias
 analysis conflates all heap allocated memory 
\begin_inset CommandInset citation
LatexCommand cite
key "emami1994aa"

\end_inset

, meaning specialization-time execution of loads and stores in that memory
 is effectively forbidden.
\end_layout

\begin_layout Subsection
Online PE
\end_layout

\begin_layout Standard
As an online PE, LLPE's primary goal is maximum specialization rather than
 to optimize efficiency of the specialization process, in contrast to C-Mix
 and Tempo, both of which used an offline strategy.
 Online PEs have been developed for a functional subset of Scheme 
\begin_inset CommandInset citation
LatexCommand cite
key "berlin1990scheme1,weise1991fusescheme"

\end_inset

, and for Prolog 
\begin_inset CommandInset citation
LatexCommand cite
key "sahlin1990mixtus"

\end_inset

.
 These systems boast large (greater than 10x) speedups applied to numerical
 kernels and toy programs respectively, but have not been evaluated on realistic
 whole programs.
 
\end_layout

\begin_layout Standard
Later online PEs targeted imperative languages including a subset Pascal
 
\begin_inset CommandInset citation
LatexCommand cite
key "meyer1999upascal"

\end_inset

 and full Java 
\begin_inset CommandInset citation
LatexCommand cite
key "shali2011hybridpe"

\end_inset

.
 The latter, named Civet, uses a hybrid approach in which the programmer
 manually annotates subsets of the program to be specialized and offline
 analysis is conducted to check the consistency of their annotations, before
 a full online PE is used at specialization time.
\end_layout

\begin_layout Subsection
Runtime PE
\end_layout

\begin_layout Standard
PEs operating at runtime have the potential to exploit specialization opportunit
ies not available to ahead-of-time PE, because all concrete parameters are
 available to them, enabling the PE to dynamically analyse and optimize
 for emergent situations which the programmer or user did not necessarily
 anticipate.
 On the other hand, runtime PEs are much more resource-constrained than
 ahead-of-time PEs because they offset any speedup to their target program
 against the cost of specialization.
 
\end_layout

\begin_layout Standard
Runtime PEs often include an ahead-of-time analysis (
\begin_inset CommandInset citation
LatexCommand cite
key "consel1996temporuntime,khan2008runtimetempl"

\end_inset

) to reduce this cost as much as possible, reducing their runtime task to
 simply filling in pre-prepared executable templates.
 The Synthesis kernel 
\begin_inset CommandInset citation
LatexCommand cite
key "pu1988synthesis"

\end_inset

 achieved significant runtime reduction using hand-written templates for
 filesystem-operation system calls.
 Tempo (see above) can use the same analysis that drives its ahead-of-time
 specializer to build templates for runtime specialization, and was later
 combined with the Synthesis kernel to automatically generate and instantiate
 the templates which were previously produced by hand 
\begin_inset CommandInset citation
LatexCommand cite
key "pu1995synthetix"

\end_inset

.
\end_layout

\begin_layout Standard
Whilst the PEs above restrict their runtime phase to instantiating templates
 in the name of efficiency, some runtime specializers such as DyC 
\begin_inset CommandInset citation
LatexCommand cite
key "grant2000dyc"

\end_inset

 and Dynamo 
\begin_inset CommandInset citation
LatexCommand cite
key "bala2000dynamo"

\end_inset

 also perform runtime peephole optimization on their generated code.
 A runtime PE for Java 
\begin_inset CommandInset citation
LatexCommand cite
key "affeldt2002javaruntime"

\end_inset

 works at the Java bytecode level and so defers optimization to the JIT
 compiler.
\end_layout

\begin_layout Subsection
Large Scale Specialization
\end_layout

\begin_layout Standard
Several prior projects have specialised entire pieces of software, or even
 entire systems.
 Both Charon 
\begin_inset CommandInset citation
LatexCommand cite
key "perianayagam2006charon"

\end_inset

 and a system based on Diablo 
\begin_inset CommandInset citation
LatexCommand cite
key "chanet2005system"

\end_inset

 specialized the Linux kernel with respect to a corpus of userspace programs
 that will be run, targeting embedded systems where the set of programs
 that can be run is tightly controlled.
 By working at the binary level they were forced to spend a great deal of
 effort disassembling and inferring high-level semantic information, and
 needed to act conservatively where that analysis was insufficient, but
 nonetheless were able to eliminate unused system calls and consequent dead
 code.
 They also introduced specialized system calls when their userspace programs
 could be shown to frequently invoke them with particular parameters.
 Their specialization of these calls was limited, however, by the fidelity
 of their disassembly and subsequent analysis.
 Their analyses achieved up to 8% runtime reduction for a specialized system
 call compared to its unspecialized equivalent, and uncompressed kernel
 image size reduction of up to 16.2% given knowledge of unused system calls.
\end_layout

\begin_layout Subsection
Whole Program Analysis and LLVM
\end_layout

\begin_layout Standard
LLVM is perfect for whole program analyses like ours because it provides
 tools to link translation units and libraries whilst retaining the high-level
 semantic information necessary for aggressive analysis and transformation.
 KLEE 
\begin_inset CommandInset citation
LatexCommand cite
key "cadar2008klee"

\end_inset

 is a program analysis tool which searches for program inputs which can
 cause crashes and other bugs by propagating value constraints through LLVM
 programs, similarly to how our tool propagates possible value sets.
 Another attribute our work shares with KLEE is that we have implemented
 a model of a subset of the POSIX API in order to allow specialization and
 analysis of programs including system calls.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In this paper we have described LLPE, a partial evaluator that targets whole
 LLVM programs running in a POSIX environment, and exhibited a prototype
 that significantly reduces runtime and code size for mid-sized example
 programs.
 We will continue to develop LLPE to address larger programs and integrate
 it to specialize across a whole system, aiming to produce a practical specializ
er for general purpose software which requires little or no user interaction.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "pldi2013"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
