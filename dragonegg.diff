diff -uN -r dragonegg-2.8/llvm-convert.cpp dragonegg-2.8-changed//llvm-convert.cpp
--- dragonegg-2.8/llvm-convert.cpp	2010-10-12 05:53:31.000000000 +0100
+++ dragonegg-2.8-changed//llvm-convert.cpp	2012-09-18 15:36:59.169258289 +0100
@@ -6746,9 +6746,15 @@
   std::string ConstraintStr;
   bool HasSideEffects = gimple_asm_volatile_p(stmt) || !outputs;
 
-  // StoreCallResultAddr - The pointer to store the result of the call through.
-  SmallVector<Value *, 4> StoreCallResultAddrs;
   SmallVector<const Type *, 4> CallResultTypes;
+  
+  // CallResultDests - Each result returned by the inline asm call is stored in
+  // a memory location.  These are listed here along with a flag indicating if
+  // the GCC type corresponding to the memory location is signed.  The type of
+  // the memory location is allowed to differ from the type of the call result,
+  // in which case the result is converted before being stored.
+  SmallVector<std::pair<Value *, bool>, 4> CallResultDests;
+
   SmallVector<bool, 4> CallResultIsSigned;
   SmallVector<std::pair<bool, unsigned>, 4> OutputLocations;
   SmallVector<tree, 4> CallResultSSANames;
@@ -6809,27 +6815,28 @@
     }
 
     LValue Dest;
-    const Type *DestValTy;
+    const Type *DestValTy = ConvertType(TREE_TYPE(Operand));
     if (TREE_CODE(Operand) == SSA_NAME) {
       // The ASM is defining an ssa name.  Store the output to a temporary, then
       // load it out again later as the ssa name.
-      DestValTy = ConvertType(TREE_TYPE(Operand));
       MemRef TmpLoc = CreateTempLoc(DestValTy);
       CallResultSSANames.push_back(Operand);
       CallResultSSATemps.push_back(TmpLoc);
       Dest = LValue(TmpLoc);
     } else {
       Dest = EmitLV(Operand);
-      DestValTy = cast<PointerType>(Dest.Ptr->getType())->getElementType();
+      assert(cast<PointerType>(Dest.Ptr->getType())->getElementType() ==
+	     DestValTy && "LValue has wrong type!");
     }
 
     assert(!Dest.isBitfield() && "Cannot assign into a bitfield!");
     if (!AllowsMem && DestValTy->isSingleValueType()) {// Reg dest -> asm return
-      StoreCallResultAddrs.push_back(Dest.Ptr);
       ConstraintStr += ",=";
       ConstraintStr += SimplifiedConstraint;
+      bool IsSigned = !TYPE_UNSIGNED(TREE_TYPE(Operand));
       CallResultTypes.push_back(DestValTy);
       CallResultIsSigned.push_back(!TYPE_UNSIGNED(TREE_TYPE(Operand)));
+      CallResultDests.push_back(std::make_pair(Dest.Ptr, IsSigned));
       OutputLocations.push_back(std::make_pair(true, CallResultTypes.size()-1));
     } else {
       ConstraintStr += ",=*";
@@ -7060,13 +7067,17 @@
   CV->setDoesNotThrow();
 
   // If the call produces a value, store it into the destination.
-  if (StoreCallResultAddrs.size() == 1)
-    Builder.CreateStore(CV, StoreCallResultAddrs[0]);
-  else if (unsigned NumResults = StoreCallResultAddrs.size()) {
-    for (unsigned i = 0; i != NumResults; ++i) {
-      Value *ValI = Builder.CreateExtractValue(CV, i, "asmresult");
-      Builder.CreateStore(ValI, StoreCallResultAddrs[i]);
-    }
+  for (unsigned i = 0, NumResults = CallResultTypes.size(); i != NumResults;
+       ++i) {
+    Value *Val = NumResults == 1 ?
+      CV : Builder.CreateExtractValue(CV, i, "asmresult");
+    bool ValIsSigned = CallResultIsSigned[i];
+
+    Value *Dest = CallResultDests[i].first;
+    const Type *DestTy = cast<PointerType>(Dest->getType())->getElementType();
+    bool DestIsSigned = CallResultDests[i].second;
+    Val = CastToAnyType(Val, ValIsSigned, DestTy, DestIsSigned);
+    Builder.CreateStore(Val, Dest);
   }
 
   // If the call defined any ssa names, associate them with their value.
diff -uN -r dragonegg-2.8/Makefile dragonegg-2.8-changed//Makefile
--- dragonegg-2.8/Makefile	2010-10-11 18:35:18.000000000 +0100
+++ dragonegg-2.8-changed//Makefile	2012-09-18 15:31:58.245245470 +0100
@@ -71,8 +71,8 @@
 
 $(TARGET_UTIL): $(TARGET_UTIL_OBJECTS)
 	@echo Linking $@
-	$(QUIET)$(CXX) -o $@ $^ $(LD_OPTIONS) \
-	$(shell $(LLVM_CONFIG) --libs support)
+	$(QUIET)$(CXX) -o $@ $^ $(shell $(LLVM_CONFIG) --libs support) \
+	$(LD_OPTIONS)
 
 %.o : $(SRC_DIR)/%.c $(TARGET_UTIL)
 	@echo Compiling $*.c
